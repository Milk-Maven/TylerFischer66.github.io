/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { META_KEY, META_OPTIONS_KEY, NgxsSimpleChange, SELECTOR_META_KEY } from '../symbols';
import { getValue } from '../utils/utils';
/**
 * @record
 * @template T, U
 */
export function StateClassInternal() { }
if (false) {
    /* Skipping unnamed member:
    [META_KEY]?: MetaDataModel;*/
    /* Skipping unnamed member:
    [META_OPTIONS_KEY]?: StoreOptions<U>;*/
}
/**
 * @record
 * @template T
 */
export function StateOperations() { }
if (false) {
    /**
     * @return {?}
     */
    StateOperations.prototype.getState = function () { };
    /**
     * @param {?} val
     * @return {?}
     */
    StateOperations.prototype.setState = function (val) { };
    /**
     * @param {?} actions
     * @return {?}
     */
    StateOperations.prototype.dispatch = function (actions) { };
}
/**
 * @record
 */
export function MetaDataModel() { }
if (false) {
    /** @type {?} */
    MetaDataModel.prototype.name;
    /** @type {?} */
    MetaDataModel.prototype.actions;
    /** @type {?} */
    MetaDataModel.prototype.defaults;
    /** @type {?} */
    MetaDataModel.prototype.path;
    /** @type {?} */
    MetaDataModel.prototype.makeRootSelector;
    /** @type {?|undefined} */
    MetaDataModel.prototype.children;
}
/**
 * @record
 */
export function RuntimeSelectorContext() { }
if (false) {
    /**
     * @param {?} key
     * @return {?}
     */
    RuntimeSelectorContext.prototype.getStateGetter = function (key) { };
    /**
     * @param {?=} localOptions
     * @return {?}
     */
    RuntimeSelectorContext.prototype.getSelectorOptions = function (localOptions) { };
}
/**
 * @record
 */
export function SharedSelectorOptions() { }
if (false) {
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.injectContainerState;
    /** @type {?|undefined} */
    SharedSelectorOptions.prototype.suppressErrors;
}
/**
 * @record
 */
export function SelectorMetaDataModel() { }
if (false) {
    /** @type {?} */
    SelectorMetaDataModel.prototype.makeRootSelector;
    /** @type {?} */
    SelectorMetaDataModel.prototype.originalFn;
    /** @type {?} */
    SelectorMetaDataModel.prototype.containerClass;
    /** @type {?} */
    SelectorMetaDataModel.prototype.selectorName;
    /** @type {?} */
    SelectorMetaDataModel.prototype.getSelectorOptions;
}
/**
 * @record
 */
export function MappedStore() { }
if (false) {
    /** @type {?} */
    MappedStore.prototype.name;
    /** @type {?} */
    MappedStore.prototype.isInitialised;
    /** @type {?} */
    MappedStore.prototype.actions;
    /** @type {?} */
    MappedStore.prototype.defaults;
    /** @type {?} */
    MappedStore.prototype.instance;
    /** @type {?} */
    MappedStore.prototype.path;
}
/**
 * @record
 */
export function StatesAndDefaults() { }
if (false) {
    /** @type {?} */
    StatesAndDefaults.prototype.defaults;
    /** @type {?} */
    StatesAndDefaults.prototype.states;
}
/**
 * @record
 * @template T
 */
export function RootStateDiff() { }
if (false) {
    /** @type {?} */
    RootStateDiff.prototype.currentAppState;
    /** @type {?} */
    RootStateDiff.prototype.newAppState;
}
/**
 * Ensures metadata is attached to the class and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureStoreMetadata(target) {
    if (!target.hasOwnProperty(META_KEY)) {
        /** @type {?} */
        var defaultMetadata_1 = {
            name: null,
            actions: {},
            defaults: {},
            path: null,
            makeRootSelector: /**
             * @param {?} context
             * @return {?}
             */
            function (context) {
                return context.getStateGetter(defaultMetadata_1.name);
            },
            children: []
        };
        Object.defineProperty(target, META_KEY, { value: defaultMetadata_1 });
    }
    return getStoreMetadata(target);
}
/**
 * Get the metadata attached to the state class if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getStoreMetadata(target) {
    return (/** @type {?} */ (target[META_KEY]));
}
/**
 * Ensures metadata is attached to the selector and returns it.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function ensureSelectorMetadata(target) {
    if (!target.hasOwnProperty(SELECTOR_META_KEY)) {
        /** @type {?} */
        var defaultMetadata = {
            makeRootSelector: null,
            originalFn: null,
            containerClass: null,
            selectorName: null,
            getSelectorOptions: (/**
             * @return {?}
             */
            function () { return ({}); })
        };
        Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });
    }
    return getSelectorMetadata(target);
}
/**
 * Get the metadata attached to the selector if it exists.
 *
 * @ignore
 * @param {?} target
 * @return {?}
 */
export function getSelectorMetadata(target) {
    return target[SELECTOR_META_KEY];
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.
 * See perf hit: https://jsperf.com/fast-value-getter-given-path/1
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function compliantPropGetter(paths) {
    /** @type {?} */
    var copyOfPaths = paths.slice();
    return (/**
     * @param {?} obj
     * @return {?}
     */
    function (obj) { return copyOfPaths.reduce((/**
     * @param {?} acc
     * @param {?} part
     * @return {?}
     */
    function (acc, part) { return acc && acc[part]; }), obj); });
}
/**
 * The generated function is faster than:
 * - pluck (Observable operator)
 * - memoize
 *
 * @ignore
 * @param {?} paths
 * @return {?}
 */
function fastPropGetter(paths) {
    /** @type {?} */
    var segments = paths;
    /** @type {?} */
    var seg = 'store.' + segments[0];
    /** @type {?} */
    var i = 0;
    /** @type {?} */
    var l = segments.length;
    /** @type {?} */
    var expr = seg;
    while (++i < l) {
        expr = expr + ' && ' + (seg = seg + '.' + segments[i]);
    }
    /** @type {?} */
    var fn = new Function('store', 'return ' + expr + ';');
    return (/** @type {?} */ (fn));
}
/**
 * Get a deeply nested value. Example:
 *
 *    getValue({ foo: bar: [] }, 'foo.bar') //=> []
 *
 * @ignore
 * @param {?} paths
 * @param {?} config
 * @return {?}
 */
export function propGetter(paths, config) {
    if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {
        return compliantPropGetter(paths);
    }
    else {
        return fastPropGetter(paths);
    }
}
/**
 * Given an array of states, it will return a object graph. Example:
 *    const states = [
 *      Cart,
 *      CartSaved,
 *      CartSavedItems
 *    ]
 *
 * would return:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * @ignore
 * @param {?} stateClasses
 * @return {?}
 */
export function buildGraph(stateClasses) {
    /** @type {?} */
    var findName = (/**
     * @param {?} stateClass
     * @return {?}
     */
    function (stateClass) {
        /** @type {?} */
        var meta = stateClasses.find((/**
         * @param {?} g
         * @return {?}
         */
        function (g) { return g === stateClass; }));
        if (!meta) {
            throw new Error("Child state not found: " + stateClass + ". \r\nYou may have forgotten to add states to module");
        }
        return (/** @type {?} */ ((/** @type {?} */ (meta[META_KEY])).name));
    });
    return stateClasses.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    function (result, stateClass) {
        var _a = (/** @type {?} */ (stateClass[META_KEY])), name = _a.name, children = _a.children;
        result[(/** @type {?} */ (name))] = (children || []).map(findName);
        return result;
    }), {});
}
/**
 * Given a states array, returns object graph
 * returning the name and state metadata. Example:
 *
 *  const graph = {
 *    cart: { metadata }
 *  };
 *
 * @ignore
 * @param {?} states
 * @return {?}
 */
export function nameToState(states) {
    return states.reduce((/**
     * @param {?} result
     * @param {?} stateClass
     * @return {?}
     */
    function (result, stateClass) {
        /** @type {?} */
        var meta = (/** @type {?} */ (stateClass[META_KEY]));
        result[(/** @type {?} */ (meta.name))] = stateClass;
        return result;
    }), {});
}
/**
 * Given a object relationship graph will return the full path
 * for the child items. Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const r = {
 *    cart: 'cart',
 *    saved: 'cart.saved',
 *    items: 'cart.saved.items'
 *  };
 *
 * @ignore
 * @param {?} obj
 * @param {?=} newObj
 * @return {?}
 */
export function findFullParentPath(obj, newObj) {
    if (newObj === void 0) { newObj = {}; }
    /** @type {?} */
    var visit = (/**
     * @param {?} child
     * @param {?} keyToFind
     * @return {?}
     */
    function (child, keyToFind) {
        for (var key in child) {
            if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {
                /** @type {?} */
                var parent_1 = visit(child, key);
                return parent_1 !== null ? parent_1 + "." + key : key;
            }
        }
        return null;
    });
    for (var key in obj) {
        if (obj.hasOwnProperty(key)) {
            /** @type {?} */
            var parent_2 = visit(obj, key);
            newObj[key] = parent_2 ? parent_2 + "." + key : key;
        }
    }
    return newObj;
}
/**
 * Given a object graph, it will return the items topologically sorted Example:
 *
 *  const graph = {
 *    cart: ['saved'],
 *    saved: ['items'],
 *    items: []
 *  };
 *
 * would return:
 *
 *  const results = [
 *    'items',
 *    'saved',
 *    'cart'
 *  ];
 *
 * @ignore
 * @param {?} graph
 * @return {?}
 */
export function topologicalSort(graph) {
    /** @type {?} */
    var sorted = [];
    /** @type {?} */
    var visited = {};
    /** @type {?} */
    var visit = (/**
     * @param {?} name
     * @param {?=} ancestors
     * @return {?}
     */
    function (name, ancestors) {
        if (ancestors === void 0) { ancestors = []; }
        if (!Array.isArray(ancestors)) {
            ancestors = [];
        }
        ancestors.push(name);
        visited[name] = true;
        graph[name].forEach((/**
         * @param {?} dep
         * @return {?}
         */
        function (dep) {
            if (ancestors.indexOf(dep) >= 0) {
                throw new Error("Circular dependency '" + dep + "' is required by '" + name + "': " + ancestors.join(' -> '));
            }
            if (visited[dep]) {
                return;
            }
            visit(dep, ancestors.slice(0));
        }));
        if (sorted.indexOf(name) < 0) {
            sorted.push(name);
        }
    });
    Object.keys(graph).forEach((/**
     * @param {?} k
     * @return {?}
     */
    function (k) { return visit(k); }));
    return sorted.reverse();
}
/**
 * Returns if the parameter is a object or not.
 *
 * @ignore
 * @param {?} obj
 * @return {?}
 */
export function isObject(obj) {
    return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';
}
/**
 * @template T
 * @param {?} mappedStore
 * @param {?} diff
 * @return {?}
 */
export function getStateDiffChanges(mappedStore, diff) {
    /** @type {?} */
    var previousValue = getValue(diff.currentAppState, mappedStore.path);
    /** @type {?} */
    var currentValue = getValue(diff.newAppState, mappedStore.path);
    return new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW50ZXJuYWxzLmpzIiwic291cmNlUm9vdCI6Im5nOi8vQG5neHMvc3RvcmUvIiwic291cmNlcyI6WyJzcmMvaW50ZXJuYWwvaW50ZXJuYWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7QUFHQSxPQUFPLEVBQ0wsUUFBUSxFQUNSLGdCQUFnQixFQUVoQixnQkFBZ0IsRUFDaEIsaUJBQWlCLEVBRWxCLE1BQU0sWUFBWSxDQUFDO0FBRXBCLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7QUFHMUMsd0NBR0M7Ozs7Ozs7Ozs7O0FBS0QscUNBTUM7Ozs7O0lBTEMscURBQWM7Ozs7O0lBRWQsd0RBQW9COzs7OztJQUVwQiw0REFBaUQ7Ozs7O0FBR25ELG1DQU9DOzs7SUFOQyw2QkFBb0I7O0lBQ3BCLGdDQUFnRDs7SUFDaEQsaUNBQWM7O0lBQ2QsNkJBQW9COztJQUNwQix5Q0FBeUM7O0lBQ3pDLGlDQUFnQzs7Ozs7QUFHbEMsNENBR0M7Ozs7OztJQUZDLHFFQUE4Qzs7Ozs7SUFDOUMsa0ZBQWdGOzs7OztBQU1sRiwyQ0FHQzs7O0lBRkMscURBQStCOztJQUMvQiwrQ0FBeUI7Ozs7O0FBRzNCLDJDQU1DOzs7SUFMQyxpREFBeUM7O0lBQ3pDLDJDQUE0Qjs7SUFDNUIsK0NBQW9COztJQUNwQiw2Q0FBNEI7O0lBQzVCLG1EQUFnRDs7Ozs7QUFHbEQsaUNBT0M7OztJQU5DLDJCQUFhOztJQUNiLG9DQUF1Qjs7SUFDdkIsOEJBQWdEOztJQUNoRCwrQkFBYzs7SUFDZCwrQkFBYzs7SUFDZCwyQkFBYTs7Ozs7QUFHZix1Q0FHQzs7O0lBRkMscUNBQWM7O0lBQ2QsbUNBQXNCOzs7Ozs7QUFLeEIsbUNBR0M7OztJQUZDLHdDQUFtQjs7SUFDbkIsb0NBQWU7Ozs7Ozs7OztBQVFqQixNQUFNLFVBQVUsbUJBQW1CLENBQUMsTUFBMEI7SUFDNUQsSUFBSSxDQUFDLE1BQU0sQ0FBQyxjQUFjLENBQUMsUUFBUSxDQUFDLEVBQUU7O1lBQzlCLGlC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LFVBQVUsQ0FBQztBQUNoRixDQUFDOzs7Ozs7O0FBRUQsTUFBTSxVQUFVLG1CQUFtQixDQUNqQyxXQUF3QixFQUN4QixJQUFzQjs7UUFFaEIsYUFBYSxHQUFNLFFBQVEsQ0FBQyxJQUFJLENBQUMsZUFBZSxFQUFFLFdBQVcsQ0FBQyxJQUFJLENBQUM7O1FBQ25FLFlBQVksR0FBTSxRQUFRLENBQUMsSUFBSSxDQUFDLFdBQVcsRUFBRSxXQUFXLENBQUMsSUFBSSxDQUFDO0lBQ3BFLE9BQU8sSUFBSSxnQkFBZ0IsQ0FBQyxhQUFhLEVBQUUsWUFBWSxFQUFFLENBQUMsV0FBVyxDQUFDLGFBQWEsQ0FBQyxDQUFDO0FBQ3ZGLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQbGFpbk9iamVjdE9mLCBTdGF0ZUNsYXNzIH0gZnJvbSAnQG5neHMvc3RvcmUvaW50ZXJuYWxzJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcblxuaW1wb3J0IHtcbiAgTUVUQV9LRVksXG4gIE1FVEFfT1BUSU9OU19LRVksXG4gIE5neHNDb25maWcsXG4gIE5neHNTaW1wbGVDaGFuZ2UsXG4gIFNFTEVDVE9SX01FVEFfS0VZLFxuICBTdG9yZU9wdGlvbnNcbn0gZnJvbSAnLi4vc3ltYm9scyc7XG5pbXBvcnQgeyBBY3Rpb25IYW5kbGVyTWV0YURhdGEgfSBmcm9tICcuLi9hY3Rpb25zL3N5bWJvbHMnO1xuaW1wb3J0IHsgZ2V0VmFsdWUgfSBmcm9tICcuLi91dGlscy91dGlscyc7XG5cbi8vIGluc3BpcmVkIGZyb20gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQzNjc0Mzg5XG5leHBvcnQgaW50ZXJmYWNlIFN0YXRlQ2xhc3NJbnRlcm5hbDxUID0gYW55LCBVID0gYW55PiBleHRlbmRzIFN0YXRlQ2xhc3M8VD4ge1xuICBbTUVUQV9LRVldPzogTWV0YURhdGFNb2RlbDtcbiAgW01FVEFfT1BUSU9OU19LRVldPzogU3RvcmVPcHRpb25zPFU+O1xufVxuXG5leHBvcnQgdHlwZSBTdGF0ZUtleUdyYXBoID0gUGxhaW5PYmplY3RPZjxzdHJpbmdbXT47XG5leHBvcnQgdHlwZSBTdGF0ZXNCeU5hbWUgPSBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD47XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3RhdGVPcGVyYXRpb25zPFQ+IHtcbiAgZ2V0U3RhdGUoKTogVDtcblxuICBzZXRTdGF0ZSh2YWw6IFQpOiBUO1xuXG4gIGRpc3BhdGNoKGFjdGlvbnM6IGFueSB8IGFueVtdKTogT2JzZXJ2YWJsZTx2b2lkPjtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNZXRhRGF0YU1vZGVsIHtcbiAgbmFtZTogc3RyaW5nIHwgbnVsbDtcbiAgYWN0aW9uczogUGxhaW5PYmplY3RPZjxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XG4gIGRlZmF1bHRzOiBhbnk7XG4gIHBhdGg6IHN0cmluZyB8IG51bGw7XG4gIG1ha2VSb290U2VsZWN0b3I6IFNlbGVjdG9yRmFjdG9yeSB8IG51bGw7XG4gIGNoaWxkcmVuPzogU3RhdGVDbGFzc0ludGVybmFsW107XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUnVudGltZVNlbGVjdG9yQ29udGV4dCB7XG4gIGdldFN0YXRlR2V0dGVyKGtleTogYW55KTogKHN0YXRlOiBhbnkpID0+IGFueTtcbiAgZ2V0U2VsZWN0b3JPcHRpb25zKGxvY2FsT3B0aW9ucz86IFNoYXJlZFNlbGVjdG9yT3B0aW9ucyk6IFNoYXJlZFNlbGVjdG9yT3B0aW9ucztcbn1cblxuZXhwb3J0IHR5cGUgU2VsZWN0RnJvbVJvb3RTdGF0ZSA9IChyb290U3RhdGU6IGFueSkgPT4gYW55O1xuZXhwb3J0IHR5cGUgU2VsZWN0b3JGYWN0b3J5ID0gKHJ1bnRpbWVDb250ZXh0OiBSdW50aW1lU2VsZWN0b3JDb250ZXh0KSA9PiBTZWxlY3RGcm9tUm9vdFN0YXRlO1xuXG5leHBvcnQgaW50ZXJmYWNlIFNoYXJlZFNlbGVjdG9yT3B0aW9ucyB7XG4gIGluamVjdENvbnRhaW5lclN0YXRlPzogYm9vbGVhbjtcbiAgc3VwcHJlc3NFcnJvcnM/OiBib29sZWFuO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdG9yTWV0YURhdGFNb2RlbCB7XG4gIG1ha2VSb290U2VsZWN0b3I6IFNlbGVjdG9yRmFjdG9yeSB8IG51bGw7XG4gIG9yaWdpbmFsRm46IEZ1bmN0aW9uIHwgbnVsbDtcbiAgY29udGFpbmVyQ2xhc3M6IGFueTtcbiAgc2VsZWN0b3JOYW1lOiBzdHJpbmcgfCBudWxsO1xuICBnZXRTZWxlY3Rvck9wdGlvbnM6ICgpID0+IFNoYXJlZFNlbGVjdG9yT3B0aW9ucztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXBwZWRTdG9yZSB7XG4gIG5hbWU6IHN0cmluZztcbiAgaXNJbml0aWFsaXNlZDogYm9vbGVhbjtcbiAgYWN0aW9uczogUGxhaW5PYmplY3RPZjxBY3Rpb25IYW5kbGVyTWV0YURhdGFbXT47XG4gIGRlZmF1bHRzOiBhbnk7XG4gIGluc3RhbmNlOiBhbnk7XG4gIHBhdGg6IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBTdGF0ZXNBbmREZWZhdWx0cyB7XG4gIGRlZmF1bHRzOiBhbnk7XG4gIHN0YXRlczogTWFwcGVkU3RvcmVbXTtcbn1cblxuZXhwb3J0IHR5cGUgQ2FsbGJhY2s8VCA9IGFueSwgViA9IGFueT4gPSAoLi4uYXJnczogVltdKSA9PiBUO1xuXG5leHBvcnQgaW50ZXJmYWNlIFJvb3RTdGF0ZURpZmY8VD4ge1xuICBjdXJyZW50QXBwU3RhdGU6IFQ7XG4gIG5ld0FwcFN0YXRlOiBUO1xufVxuXG4vKipcbiAqIEVuc3VyZXMgbWV0YWRhdGEgaXMgYXR0YWNoZWQgdG8gdGhlIGNsYXNzIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVN0b3JlTWV0YWRhdGEodGFyZ2V0OiBTdGF0ZUNsYXNzSW50ZXJuYWwpOiBNZXRhRGF0YU1vZGVsIHtcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoTUVUQV9LRVkpKSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBNZXRhRGF0YU1vZGVsID0ge1xuICAgICAgbmFtZTogbnVsbCxcbiAgICAgIGFjdGlvbnM6IHt9LFxuICAgICAgZGVmYXVsdHM6IHt9LFxuICAgICAgcGF0aDogbnVsbCxcbiAgICAgIG1ha2VSb290U2VsZWN0b3IoY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCkge1xuICAgICAgICByZXR1cm4gY29udGV4dC5nZXRTdGF0ZUdldHRlcihkZWZhdWx0TWV0YWRhdGEubmFtZSk7XG4gICAgICB9LFxuICAgICAgY2hpbGRyZW46IFtdXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIE1FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XG4gIH1cbiAgcmV0dXJuIGdldFN0b3JlTWV0YWRhdGEodGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG1ldGFkYXRhIGF0dGFjaGVkIHRvIHRoZSBzdGF0ZSBjbGFzcyBpZiBpdCBleGlzdHMuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RvcmVNZXRhZGF0YSh0YXJnZXQ6IFN0YXRlQ2xhc3NJbnRlcm5hbCk6IE1ldGFEYXRhTW9kZWwge1xuICByZXR1cm4gdGFyZ2V0W01FVEFfS0VZXSE7XG59XG5cbi8qKlxuICogRW5zdXJlcyBtZXRhZGF0YSBpcyBhdHRhY2hlZCB0byB0aGUgc2VsZWN0b3IgYW5kIHJldHVybnMgaXQuXG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZW5zdXJlU2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQ6IEZ1bmN0aW9uKTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcbiAgaWYgKCF0YXJnZXQuaGFzT3duUHJvcGVydHkoU0VMRUNUT1JfTUVUQV9LRVkpKSB7XG4gICAgY29uc3QgZGVmYXVsdE1ldGFkYXRhOiBTZWxlY3Rvck1ldGFEYXRhTW9kZWwgPSB7XG4gICAgICBtYWtlUm9vdFNlbGVjdG9yOiBudWxsLFxuICAgICAgb3JpZ2luYWxGbjogbnVsbCxcbiAgICAgIGNvbnRhaW5lckNsYXNzOiBudWxsLFxuICAgICAgc2VsZWN0b3JOYW1lOiBudWxsLFxuICAgICAgZ2V0U2VsZWN0b3JPcHRpb25zOiAoKSA9PiAoe30pXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIFNFTEVDVE9SX01FVEFfS0VZLCB7IHZhbHVlOiBkZWZhdWx0TWV0YWRhdGEgfSk7XG4gIH1cblxuICByZXR1cm4gZ2V0U2VsZWN0b3JNZXRhZGF0YSh0YXJnZXQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgbWV0YWRhdGEgYXR0YWNoZWQgdG8gdGhlIHNlbGVjdG9yIGlmIGl0IGV4aXN0cy5cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTZWxlY3Rvck1ldGFkYXRhKHRhcmdldDogYW55KTogU2VsZWN0b3JNZXRhRGF0YU1vZGVsIHtcbiAgcmV0dXJuIHRhcmdldFtTRUxFQ1RPUl9NRVRBX0tFWV07XG59XG5cbi8qKlxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcbiAqXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cbiAqXG4gKiBOb3RlOiBUaGlzIGlzIG5vdCBhcyBmYXN0IGFzIHRoZSBgZmFzdFByb3BHZXR0ZXJgIGJ1dCBpcyBzdHJpY3QgQ29udGVudCBTZWN1cml0eSBQb2xpY3kgY29tcGxpYW50LlxuICogU2VlIHBlcmYgaGl0OiBodHRwczovL2pzcGVyZi5jb20vZmFzdC12YWx1ZS1nZXR0ZXItZ2l2ZW4tcGF0aC8xXG4gKlxuICogQGlnbm9yZVxuICovXG5mdW5jdGlvbiBjb21wbGlhbnRQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XG4gIGNvbnN0IGNvcHlPZlBhdGhzID0gcGF0aHMuc2xpY2UoKTtcbiAgcmV0dXJuIG9iaiA9PiBjb3B5T2ZQYXRocy5yZWR1Y2UoKGFjYzogYW55LCBwYXJ0OiBzdHJpbmcpID0+IGFjYyAmJiBhY2NbcGFydF0sIG9iaik7XG59XG5cbi8qKlxuICogVGhlIGdlbmVyYXRlZCBmdW5jdGlvbiBpcyBmYXN0ZXIgdGhhbjpcbiAqIC0gcGx1Y2sgKE9ic2VydmFibGUgb3BlcmF0b3IpXG4gKiAtIG1lbW9pemVcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmZ1bmN0aW9uIGZhc3RQcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSk6ICh4OiBhbnkpID0+IGFueSB7XG4gIGNvbnN0IHNlZ21lbnRzID0gcGF0aHM7XG4gIGxldCBzZWcgPSAnc3RvcmUuJyArIHNlZ21lbnRzWzBdO1xuICBsZXQgaSA9IDA7XG4gIGNvbnN0IGwgPSBzZWdtZW50cy5sZW5ndGg7XG5cbiAgbGV0IGV4cHIgPSBzZWc7XG4gIHdoaWxlICgrK2kgPCBsKSB7XG4gICAgZXhwciA9IGV4cHIgKyAnICYmICcgKyAoc2VnID0gc2VnICsgJy4nICsgc2VnbWVudHNbaV0pO1xuICB9XG5cbiAgY29uc3QgZm4gPSBuZXcgRnVuY3Rpb24oJ3N0b3JlJywgJ3JldHVybiAnICsgZXhwciArICc7Jyk7XG5cbiAgcmV0dXJuIDwoeDogYW55KSA9PiBhbnk+Zm47XG59XG5cbi8qKlxuICogR2V0IGEgZGVlcGx5IG5lc3RlZCB2YWx1ZS4gRXhhbXBsZTpcbiAqXG4gKiAgICBnZXRWYWx1ZSh7IGZvbzogYmFyOiBbXSB9LCAnZm9vLmJhcicpIC8vPT4gW11cbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcm9wR2V0dGVyKHBhdGhzOiBzdHJpbmdbXSwgY29uZmlnOiBOZ3hzQ29uZmlnKSB7XG4gIGlmIChjb25maWcgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkgJiYgY29uZmlnLmNvbXBhdGliaWxpdHkuc3RyaWN0Q29udGVudFNlY3VyaXR5UG9saWN5KSB7XG4gICAgcmV0dXJuIGNvbXBsaWFudFByb3BHZXR0ZXIocGF0aHMpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBmYXN0UHJvcEdldHRlcihwYXRocyk7XG4gIH1cbn1cblxuLyoqXG4gKiBHaXZlbiBhbiBhcnJheSBvZiBzdGF0ZXMsIGl0IHdpbGwgcmV0dXJuIGEgb2JqZWN0IGdyYXBoLiBFeGFtcGxlOlxuICogICAgY29uc3Qgc3RhdGVzID0gW1xuICogICAgICBDYXJ0LFxuICogICAgICBDYXJ0U2F2ZWQsXG4gKiAgICAgIENhcnRTYXZlZEl0ZW1zXG4gKiAgICBdXG4gKlxuICogd291bGQgcmV0dXJuOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXG4gKiAgICBpdGVtczogW11cbiAqICB9O1xuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkR3JhcGgoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlS2V5R3JhcGgge1xuICBjb25zdCBmaW5kTmFtZSA9IChzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcbiAgICBjb25zdCBtZXRhID0gc3RhdGVDbGFzc2VzLmZpbmQoZyA9PiBnID09PSBzdGF0ZUNsYXNzKTtcbiAgICBpZiAoIW1ldGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYENoaWxkIHN0YXRlIG5vdCBmb3VuZDogJHtzdGF0ZUNsYXNzfS4gXFxyXFxuWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBhZGQgc3RhdGVzIHRvIG1vZHVsZWBcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1ldGFbTUVUQV9LRVldIS5uYW1lITtcbiAgfTtcblxuICByZXR1cm4gc3RhdGVDbGFzc2VzLnJlZHVjZTxTdGF0ZUtleUdyYXBoPihcbiAgICAocmVzdWx0OiBTdGF0ZUtleUdyYXBoLCBzdGF0ZUNsYXNzOiBTdGF0ZUNsYXNzSW50ZXJuYWwpID0+IHtcbiAgICAgIGNvbnN0IHsgbmFtZSwgY2hpbGRyZW4gfSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcbiAgICAgIHJlc3VsdFtuYW1lIV0gPSAoY2hpbGRyZW4gfHwgW10pLm1hcChmaW5kTmFtZSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIHN0YXRlcyBhcnJheSwgcmV0dXJucyBvYmplY3QgZ3JhcGhcbiAqIHJldHVybmluZyB0aGUgbmFtZSBhbmQgc3RhdGUgbWV0YWRhdGEuIEV4YW1wbGU6XG4gKlxuICogIGNvbnN0IGdyYXBoID0ge1xuICogICAgY2FydDogeyBtZXRhZGF0YSB9XG4gKiAgfTtcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBuYW1lVG9TdGF0ZShzdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdKTogUGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+IHtcbiAgcmV0dXJuIHN0YXRlcy5yZWR1Y2U8UGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+PihcbiAgICAocmVzdWx0OiBQbGFpbk9iamVjdE9mPFN0YXRlQ2xhc3NJbnRlcm5hbD4sIHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCkgPT4ge1xuICAgICAgY29uc3QgbWV0YSA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcbiAgICAgIHJlc3VsdFttZXRhLm5hbWUhXSA9IHN0YXRlQ2xhc3M7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0sXG4gICAge31cbiAgKTtcbn1cblxuLyoqXG4gKiBHaXZlbiBhIG9iamVjdCByZWxhdGlvbnNoaXAgZ3JhcGggd2lsbCByZXR1cm4gdGhlIGZ1bGwgcGF0aFxuICogZm9yIHRoZSBjaGlsZCBpdGVtcy4gRXhhbXBsZTpcbiAqXG4gKiAgY29uc3QgZ3JhcGggPSB7XG4gKiAgICBjYXJ0OiBbJ3NhdmVkJ10sXG4gKiAgICBzYXZlZDogWydpdGVtcyddLFxuICogICAgaXRlbXM6IFtdXG4gKiAgfTtcbiAqXG4gKiB3b3VsZCByZXR1cm46XG4gKlxuICogIGNvbnN0IHIgPSB7XG4gKiAgICBjYXJ0OiAnY2FydCcsXG4gKiAgICBzYXZlZDogJ2NhcnQuc2F2ZWQnLFxuICogICAgaXRlbXM6ICdjYXJ0LnNhdmVkLml0ZW1zJ1xuICogIH07XG4gKlxuICogQGlnbm9yZVxuICovXG5leHBvcnQgZnVuY3Rpb24gZmluZEZ1bGxQYXJlbnRQYXRoKFxuICBvYmo6IFN0YXRlS2V5R3JhcGgsXG4gIG5ld09iajogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0ge31cbik6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiB7XG4gIGNvbnN0IHZpc2l0ID0gKGNoaWxkOiBTdGF0ZUtleUdyYXBoLCBrZXlUb0ZpbmQ6IHN0cmluZyk6IHN0cmluZyB8IG51bGwgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IGluIGNoaWxkKSB7XG4gICAgICBpZiAoY2hpbGQuaGFzT3duUHJvcGVydHkoa2V5KSAmJiBjaGlsZFtrZXldLmluZGV4T2Yoa2V5VG9GaW5kKSA+PSAwKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KGNoaWxkLCBrZXkpO1xuICAgICAgICByZXR1cm4gcGFyZW50ICE9PSBudWxsID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbiAgfTtcblxuICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIGNvbnN0IHBhcmVudCA9IHZpc2l0KG9iaiwga2V5KTtcbiAgICAgIG5ld09ialtrZXldID0gcGFyZW50ID8gYCR7cGFyZW50fS4ke2tleX1gIDoga2V5O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbi8qKlxuICogR2l2ZW4gYSBvYmplY3QgZ3JhcGgsIGl0IHdpbGwgcmV0dXJuIHRoZSBpdGVtcyB0b3BvbG9naWNhbGx5IHNvcnRlZCBFeGFtcGxlOlxuICpcbiAqICBjb25zdCBncmFwaCA9IHtcbiAqICAgIGNhcnQ6IFsnc2F2ZWQnXSxcbiAqICAgIHNhdmVkOiBbJ2l0ZW1zJ10sXG4gKiAgICBpdGVtczogW11cbiAqICB9O1xuICpcbiAqIHdvdWxkIHJldHVybjpcbiAqXG4gKiAgY29uc3QgcmVzdWx0cyA9IFtcbiAqICAgICdpdGVtcycsXG4gKiAgICAnc2F2ZWQnLFxuICogICAgJ2NhcnQnXG4gKiAgXTtcbiAqXG4gKiBAaWdub3JlXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b3BvbG9naWNhbFNvcnQoZ3JhcGg6IFN0YXRlS2V5R3JhcGgpOiBzdHJpbmdbXSB7XG4gIGNvbnN0IHNvcnRlZDogc3RyaW5nW10gPSBbXTtcbiAgY29uc3QgdmlzaXRlZDogUGxhaW5PYmplY3RPZjxib29sZWFuPiA9IHt9O1xuXG4gIGNvbnN0IHZpc2l0ID0gKG5hbWU6IHN0cmluZywgYW5jZXN0b3JzOiBzdHJpbmdbXSA9IFtdKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFuY2VzdG9ycykpIHtcbiAgICAgIGFuY2VzdG9ycyA9IFtdO1xuICAgIH1cblxuICAgIGFuY2VzdG9ycy5wdXNoKG5hbWUpO1xuICAgIHZpc2l0ZWRbbmFtZV0gPSB0cnVlO1xuXG4gICAgZ3JhcGhbbmFtZV0uZm9yRWFjaCgoZGVwOiBzdHJpbmcpID0+IHtcbiAgICAgIGlmIChhbmNlc3RvcnMuaW5kZXhPZihkZXApID49IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDaXJjdWxhciBkZXBlbmRlbmN5ICcke2RlcH0nIGlzIHJlcXVpcmVkIGJ5ICcke25hbWV9JzogJHthbmNlc3RvcnMuam9pbignIC0+ICcpfWBcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHZpc2l0ZWRbZGVwXSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZpc2l0KGRlcCwgYW5jZXN0b3JzLnNsaWNlKDApKTtcbiAgICB9KTtcblxuICAgIGlmIChzb3J0ZWQuaW5kZXhPZihuYW1lKSA8IDApIHtcbiAgICAgIHNvcnRlZC5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfTtcblxuICBPYmplY3Qua2V5cyhncmFwaCkuZm9yRWFjaChrID0+IHZpc2l0KGspKTtcblxuICByZXR1cm4gc29ydGVkLnJldmVyc2UoKTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGlmIHRoZSBwYXJhbWV0ZXIgaXMgYSBvYmplY3Qgb3Igbm90LlxuICpcbiAqIEBpZ25vcmVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzT2JqZWN0KG9iajogYW55KSB7XG4gIHJldHVybiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgb2JqICE9PSBudWxsKSB8fCB0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0U3RhdGVEaWZmQ2hhbmdlczxUPihcbiAgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlLFxuICBkaWZmOiBSb290U3RhdGVEaWZmPFQ+XG4pOiBOZ3hzU2ltcGxlQ2hhbmdlIHtcbiAgY29uc3QgcHJldmlvdXNWYWx1ZTogVCA9IGdldFZhbHVlKGRpZmYuY3VycmVudEFwcFN0YXRlLCBtYXBwZWRTdG9yZS5wYXRoKTtcbiAgY29uc3QgY3VycmVudFZhbHVlOiBUID0gZ2V0VmFsdWUoZGlmZi5uZXdBcHBTdGF0ZSwgbWFwcGVkU3RvcmUucGF0aCk7XG4gIHJldHVybiBuZXcgTmd4c1NpbXBsZUNoYW5nZShwcmV2aW91c1ZhbHVlLCBjdXJyZW50VmFsdWUsICFtYXBwZWRTdG9yZS5pc0luaXRpYWxpc2VkKTtcbn1cbiJdfQ==