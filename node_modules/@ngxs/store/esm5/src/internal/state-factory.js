/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';
import { forkJoin, from, Observable, of, throwError } from 'rxjs';
import { catchError, defaultIfEmpty, filter, map, mergeMap, shareReplay, takeUntil } from 'rxjs/operators';
import { META_KEY, NgxsConfig } from '../symbols';
import { buildGraph, findFullParentPath, isObject, nameToState, propGetter, topologicalSort } from './internals';
import { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';
import { ofActionDispatched } from '../operators/of-action';
import { InternalActions } from '../actions-stream';
import { InternalDispatchedActionResults } from '../internal/dispatcher';
import { StateContextFactory } from '../internal/state-context-factory';
import { StoreValidators } from '../utils/store-validators';
import { INITIAL_STATE_TOKEN, memoize } from '@ngxs/store/internals';
/**
 * State factory class
 * @ignore
 */
var StateFactory = /** @class */ (function () {
    function StateFactory(_injector, _config, _parentFactory, _actions, _actionResults, _stateContextFactory, _initialState) {
        var _this = this;
        this._injector = _injector;
        this._config = _config;
        this._parentFactory = _parentFactory;
        this._actions = _actions;
        this._actionResults = _actionResults;
        this._stateContextFactory = _stateContextFactory;
        this._initialState = _initialState;
        this._connected = false;
        this._states = [];
        this._statesByName = {};
        this._statePaths = {};
        this.getRuntimeSelectorContext = memoize((/**
         * @return {?}
         */
        function () {
            /** @type {?} */
            var stateFactory = _this;
            /** @type {?} */
            var context = _this._parentFactory
                ? _this._parentFactory.getRuntimeSelectorContext()
                : {
                    getStateGetter: /**
                     * @param {?} key
                     * @return {?}
                     */
                    function (key) {
                        /** @type {?} */
                        var path = stateFactory.statePaths[key];
                        return path ? propGetter(path.split('.'), stateFactory._config) : (/**
                         * @return {?}
                         */
                        function () { return undefined; });
                    },
                    getSelectorOptions: /**
                     * @param {?=} localOptions
                     * @return {?}
                     */
                    function (localOptions) {
                        /** @type {?} */
                        var globalSelectorOptions = stateFactory._config.selectorOptions;
                        return tslib_1.__assign({}, globalSelectorOptions, (localOptions || {}));
                    }
                };
            return context;
        }));
    }
    Object.defineProperty(StateFactory.prototype, "states", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.states : this._states;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statesByName", {
        get: /**
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StateFactory.prototype, "statePaths", {
        get: /**
         * @private
         * @return {?}
         */
        function () {
            return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    StateFactory.cloneDefaults = /**
     * @private
     * @param {?} defaults
     * @return {?}
     */
    function (defaults) {
        /** @type {?} */
        var value = {};
        if (Array.isArray(defaults)) {
            value = defaults.slice();
        }
        else if (isObject(defaults)) {
            value = tslib_1.__assign({}, defaults);
        }
        else if (defaults === undefined) {
            value = {};
        }
        else {
            value = defaults;
        }
        return value;
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.checkStatesAreValid = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        stateClasses.forEach(StoreValidators.getValidStateMeta);
    };
    /**
     * Add a new state to the global defs.
     */
    /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.add = /**
     * Add a new state to the global defs.
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_1, _a;
        StateFactory.checkStatesAreValid(stateClasses);
        var newStates = this.addToStatesMap(stateClasses).newStates;
        if (!newStates.length)
            return [];
        /** @type {?} */
        var stateGraph = buildGraph(newStates);
        /** @type {?} */
        var sortedStates = topologicalSort(stateGraph);
        /** @type {?} */
        var paths = findFullParentPath(stateGraph);
        /** @type {?} */
        var nameGraph = nameToState(newStates);
        /** @type {?} */
        var bootstrappedStores = [];
        try {
            for (var sortedStates_1 = tslib_1.__values(sortedStates), sortedStates_1_1 = sortedStates_1.next(); !sortedStates_1_1.done; sortedStates_1_1 = sortedStates_1.next()) {
                var name_1 = sortedStates_1_1.value;
                /** @type {?} */
                var stateClass = nameGraph[name_1];
                /** @type {?} */
                var path = paths[name_1];
                /** @type {?} */
                var meta = (/** @type {?} */ (stateClass[META_KEY]));
                this.addRuntimeInfoToMeta(meta, path);
                /** @type {?} */
                var stateMap = {
                    name: name_1,
                    path: path,
                    isInitialised: false,
                    actions: meta.actions,
                    instance: this._injector.get(stateClass),
                    defaults: StateFactory.cloneDefaults(meta.defaults)
                };
                // ensure our store hasn't already been added
                // but don't throw since it could be lazy
                // loaded from different paths
                if (!this.hasBeenMountedAndBootstrapped(name_1, path)) {
                    bootstrappedStores.push(stateMap);
                }
                this.states.push(stateMap);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (sortedStates_1_1 && !sortedStates_1_1.done && (_a = sortedStates_1.return)) _a.call(sortedStates_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return bootstrappedStores;
    };
    /**
     * Add a set of states to the store and return the defaults
     */
    /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addAndReturnDefaults = /**
     * Add a set of states to the store and return the defaults
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        /** @type {?} */
        var classes = stateClasses || [];
        /** @type {?} */
        var mappedStores = this.add(classes);
        /** @type {?} */
        var defaults = mappedStores.reduce((/**
         * @param {?} result
         * @param {?} mappedStore
         * @return {?}
         */
        function (result, mappedStore) {
            return setValue(result, mappedStore.path, mappedStore.defaults);
        }), {});
        return { defaults: defaults, states: mappedStores };
    };
    /**
     * Bind the actions to the handlers
     */
    /**
     * Bind the actions to the handlers
     * @return {?}
     */
    StateFactory.prototype.connectActionHandlers = /**
     * Bind the actions to the handlers
     * @return {?}
     */
    function () {
        var _this = this;
        if (this._connected)
            return;
        this._actions
            .pipe(filter((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return ctx.status === "DISPATCHED" /* Dispatched */; })), mergeMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var action = _a.action;
            return _this.invokeActions(_this._actions, (/** @type {?} */ (action))).pipe(map((/**
             * @return {?}
             */
            function () { return (/** @type {?} */ ({ action: action, status: "SUCCESSFUL" /* Successful */ })); })), defaultIfEmpty((/** @type {?} */ ({ action: action, status: "CANCELED" /* Canceled */ }))), catchError((/**
             * @param {?} error
             * @return {?}
             */
            function (error) {
                return of((/** @type {?} */ ({ action: action, status: "ERRORED" /* Errored */, error: error })));
            })));
        })))
            .subscribe((/**
         * @param {?} ctx
         * @return {?}
         */
        function (ctx) { return _this._actionResults.next(ctx); }));
        this._connected = true;
    };
    /**
     * Invoke actions on the states.
     */
    /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    StateFactory.prototype.invokeActions = /**
     * Invoke actions on the states.
     * @param {?} actions$
     * @param {?} action
     * @return {?}
     */
    function (actions$, action) {
        var e_2, _a, e_3, _b;
        /** @type {?} */
        var results = [];
        try {
            for (var _c = tslib_1.__values(this.states), _d = _c.next(); !_d.done; _d = _c.next()) {
                var metadata = _d.value;
                /** @type {?} */
                var type = (/** @type {?} */ (getActionTypeFromInstance(action)));
                /** @type {?} */
                var actionMetas = metadata.actions[type];
                if (actionMetas) {
                    try {
                        for (var actionMetas_1 = tslib_1.__values(actionMetas), actionMetas_1_1 = actionMetas_1.next(); !actionMetas_1_1.done; actionMetas_1_1 = actionMetas_1.next()) {
                            var actionMeta = actionMetas_1_1.value;
                            /** @type {?} */
                            var stateContext = this._stateContextFactory.createStateContext(metadata);
                            try {
                                /** @type {?} */
                                var result = metadata.instance[actionMeta.fn](stateContext, action);
                                if (result instanceof Promise) {
                                    result = from(result);
                                }
                                if (result instanceof Observable) {
                                    if (actionMeta.options.cancelUncompleted) {
                                        // todo: ofActionDispatched should be used with action class
                                        result = result.pipe(takeUntil(actions$.pipe(ofActionDispatched((/** @type {?} */ (action))))));
                                    }
                                }
                                else {
                                    result = of({}).pipe(shareReplay());
                                }
                                results.push(result);
                            }
                            catch (e) {
                                results.push(throwError(e));
                            }
                        }
                    }
                    catch (e_3_1) { e_3 = { error: e_3_1 }; }
                    finally {
                        try {
                            if (actionMetas_1_1 && !actionMetas_1_1.done && (_b = actionMetas_1.return)) _b.call(actionMetas_1);
                        }
                        finally { if (e_3) throw e_3.error; }
                    }
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
            }
            finally { if (e_2) throw e_2.error; }
        }
        if (!results.length) {
            results.push(of({}));
        }
        return forkJoin(results);
    };
    /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    StateFactory.prototype.addToStatesMap = /**
     * @private
     * @param {?} stateClasses
     * @return {?}
     */
    function (stateClasses) {
        var e_4, _a;
        /** @type {?} */
        var newStates = [];
        /** @type {?} */
        var statesMap = this.statesByName;
        try {
            for (var stateClasses_1 = tslib_1.__values(stateClasses), stateClasses_1_1 = stateClasses_1.next(); !stateClasses_1_1.done; stateClasses_1_1 = stateClasses_1.next()) {
                var stateClass = stateClasses_1_1.value;
                /** @type {?} */
                var stateName = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);
                /** @type {?} */
                var unmountedState = !statesMap[stateName];
                if (unmountedState) {
                    newStates.push(stateClass);
                    statesMap[stateName] = stateClass;
                }
            }
        }
        catch (e_4_1) { e_4 = { error: e_4_1 }; }
        finally {
            try {
                if (stateClasses_1_1 && !stateClasses_1_1.done && (_a = stateClasses_1.return)) _a.call(stateClasses_1);
            }
            finally { if (e_4) throw e_4.error; }
        }
        return { newStates: newStates };
    };
    /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.addRuntimeInfoToMeta = /**
     * @private
     * @param {?} meta
     * @param {?} path
     * @return {?}
     */
    function (meta, path) {
        this.statePaths[(/** @type {?} */ (meta.name))] = path;
        // TODO: v4 - we plan to get rid of the path property because it is non-deterministic
        // we can do this when we get rid of the incorrectly exposed getStoreMetadata
        // We will need to come up with an alternative in v4 because this is used by many plugins
        meta.path = path;
    };
    /**
     * @description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @param name
     * @param path
     */
    /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    StateFactory.prototype.hasBeenMountedAndBootstrapped = /**
     * \@description
     * the method checks if the state has already been added to the tree
     * and completed the life cycle
     * @private
     * @param {?} name
     * @param {?} path
     * @return {?}
     */
    function (name, path) {
        /** @type {?} */
        var valueIsBootstrappedInInitialState = getValue(this._initialState, path) !== undefined;
        return this.statesByName[name] && valueIsBootstrappedInInitialState;
    };
    StateFactory.decorators = [
        { type: Injectable }
    ];
    /** @nocollapse */
    StateFactory.ctorParameters = function () { return [
        { type: Injector },
        { type: NgxsConfig },
        { type: StateFactory, decorators: [{ type: Optional }, { type: SkipSelf }] },
        { type: InternalActions },
        { type: InternalDispatchedActionResults },
        { type: StateContextFactory },
        { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [INITIAL_STATE_TOKEN,] }] }
    ]; };
    return StateFactory;
}());
export { StateFactory };
if (false) {
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._connected;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._states;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statesByName;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._statePaths;
    /** @type {?} */
    StateFactory.prototype.getRuntimeSelectorContext;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._injector;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._config;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._parentFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actions;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._actionResults;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._stateContextFactory;
    /**
     * @type {?}
     * @private
     */
    StateFactory.prototype._initialState;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUtZmFjdG9yeS5qcyIsInNvdXJjZVJvb3QiOiJuZzovL0BuZ3hzL3N0b3JlLyIsInNvdXJjZXMiOlsic3JjL2ludGVybmFsL3N0YXRlLWZhY3RvcnkudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxRQUFRLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNqRixPQUFPLEVBQUUsUUFBUSxFQUFFLElBQUksRUFBRSxVQUFVLEVBQUUsRUFBRSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNsRSxPQUFPLEVBQ0wsVUFBVSxFQUNWLGNBQWMsRUFDZCxNQUFNLEVBQ04sR0FBRyxFQUNILFFBQVEsRUFDUixXQUFXLEVBQ1gsU0FBUyxFQUNWLE1BQU0sZ0JBQWdCLENBQUM7QUFFeEIsT0FBTyxFQUFFLFFBQVEsRUFBRSxVQUFVLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDbEQsT0FBTyxFQUNMLFVBQVUsRUFDVixrQkFBa0IsRUFDbEIsUUFBUSxFQUdSLFdBQVcsRUFDWCxVQUFVLEVBS1YsZUFBZSxFQUdoQixNQUFNLGFBQWEsQ0FBQztBQUNyQixPQUFPLEVBQUUseUJBQXlCLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQy9FLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBQzVELE9BQU8sRUFBK0IsZUFBZSxFQUFFLE1BQU0sbUJBQW1CLENBQUM7QUFDakYsT0FBTyxFQUFFLCtCQUErQixFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDekUsT0FBTyxFQUFFLG1CQUFtQixFQUFFLE1BQU0sbUNBQW1DLENBQUM7QUFDeEUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FBQzVELE9BQU8sRUFBRSxtQkFBbUIsRUFBaUIsT0FBTyxFQUFFLE1BQU0sdUJBQXVCLENBQUM7Ozs7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TSxTQUFDLG1CQUFtQjs7SUFrTy9CLG1CQUFDO0NBQUEsQUFoUEQsSUFnUEM7U0EvT1ksWUFBWTs7Ozs7O0lBQ3ZCLGtDQUEyQjs7Ozs7SUFnQjNCLCtCQUFvQzs7Ozs7SUFNcEMscUNBQXlDOzs7OztJQU16QyxtQ0FBZ0Q7O0lBTWhELGlEQWtCRzs7Ozs7SUFqREQsaUNBQTJCOzs7OztJQUMzQiwrQkFBMkI7Ozs7O0lBQzNCLHNDQUVvQzs7Ozs7SUFDcEMsZ0NBQWlDOzs7OztJQUNqQyxzQ0FBdUQ7Ozs7O0lBQ3ZELDRDQUFpRDs7Ozs7SUFDakQscUNBRTBCIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgSW5qZWN0YWJsZSwgSW5qZWN0b3IsIE9wdGlvbmFsLCBTa2lwU2VsZiwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBmb3JrSm9pbiwgZnJvbSwgT2JzZXJ2YWJsZSwgb2YsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7XG4gIGNhdGNoRXJyb3IsXG4gIGRlZmF1bHRJZkVtcHR5LFxuICBmaWx0ZXIsXG4gIG1hcCxcbiAgbWVyZ2VNYXAsXG4gIHNoYXJlUmVwbGF5LFxuICB0YWtlVW50aWxcbn0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5pbXBvcnQgeyBNRVRBX0tFWSwgTmd4c0NvbmZpZyB9IGZyb20gJy4uL3N5bWJvbHMnO1xuaW1wb3J0IHtcbiAgYnVpbGRHcmFwaCxcbiAgZmluZEZ1bGxQYXJlbnRQYXRoLFxuICBpc09iamVjdCxcbiAgTWFwcGVkU3RvcmUsXG4gIE1ldGFEYXRhTW9kZWwsXG4gIG5hbWVUb1N0YXRlLFxuICBwcm9wR2V0dGVyLFxuICBTdGF0ZUNsYXNzSW50ZXJuYWwsXG4gIFN0YXRlS2V5R3JhcGgsXG4gIFN0YXRlc0FuZERlZmF1bHRzLFxuICBTdGF0ZXNCeU5hbWUsXG4gIHRvcG9sb2dpY2FsU29ydCxcbiAgUnVudGltZVNlbGVjdG9yQ29udGV4dCxcbiAgU2hhcmVkU2VsZWN0b3JPcHRpb25zXG59IGZyb20gJy4vaW50ZXJuYWxzJztcbmltcG9ydCB7IGdldEFjdGlvblR5cGVGcm9tSW5zdGFuY2UsIGdldFZhbHVlLCBzZXRWYWx1ZSB9IGZyb20gJy4uL3V0aWxzL3V0aWxzJztcbmltcG9ydCB7IG9mQWN0aW9uRGlzcGF0Y2hlZCB9IGZyb20gJy4uL29wZXJhdG9ycy9vZi1hY3Rpb24nO1xuaW1wb3J0IHsgQWN0aW9uQ29udGV4dCwgQWN0aW9uU3RhdHVzLCBJbnRlcm5hbEFjdGlvbnMgfSBmcm9tICcuLi9hY3Rpb25zLXN0cmVhbSc7XG5pbXBvcnQgeyBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzIH0gZnJvbSAnLi4vaW50ZXJuYWwvZGlzcGF0Y2hlcic7XG5pbXBvcnQgeyBTdGF0ZUNvbnRleHRGYWN0b3J5IH0gZnJvbSAnLi4vaW50ZXJuYWwvc3RhdGUtY29udGV4dC1mYWN0b3J5JztcbmltcG9ydCB7IFN0b3JlVmFsaWRhdG9ycyB9IGZyb20gJy4uL3V0aWxzL3N0b3JlLXZhbGlkYXRvcnMnO1xuaW1wb3J0IHsgSU5JVElBTF9TVEFURV9UT0tFTiwgUGxhaW5PYmplY3RPZiwgbWVtb2l6ZSB9IGZyb20gJ0BuZ3hzL3N0b3JlL2ludGVybmFscyc7XG5cbi8qKlxuICogU3RhdGUgZmFjdG9yeSBjbGFzc1xuICogQGlnbm9yZVxuICovXG5ASW5qZWN0YWJsZSgpXG5leHBvcnQgY2xhc3MgU3RhdGVGYWN0b3J5IHtcbiAgcHJpdmF0ZSBfY29ubmVjdGVkID0gZmFsc2U7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBfaW5qZWN0b3I6IEluamVjdG9yLFxuICAgIHByaXZhdGUgX2NvbmZpZzogTmd4c0NvbmZpZyxcbiAgICBAT3B0aW9uYWwoKVxuICAgIEBTa2lwU2VsZigpXG4gICAgcHJpdmF0ZSBfcGFyZW50RmFjdG9yeTogU3RhdGVGYWN0b3J5LFxuICAgIHByaXZhdGUgX2FjdGlvbnM6IEludGVybmFsQWN0aW9ucyxcbiAgICBwcml2YXRlIF9hY3Rpb25SZXN1bHRzOiBJbnRlcm5hbERpc3BhdGNoZWRBY3Rpb25SZXN1bHRzLFxuICAgIHByaXZhdGUgX3N0YXRlQ29udGV4dEZhY3Rvcnk6IFN0YXRlQ29udGV4dEZhY3RvcnksXG4gICAgQE9wdGlvbmFsKClcbiAgICBASW5qZWN0KElOSVRJQUxfU1RBVEVfVE9LRU4pXG4gICAgcHJpdmF0ZSBfaW5pdGlhbFN0YXRlOiBhbnlcbiAgKSB7fVxuXG4gIHByaXZhdGUgX3N0YXRlczogTWFwcGVkU3RvcmVbXSA9IFtdO1xuXG4gIHB1YmxpYyBnZXQgc3RhdGVzKCk6IE1hcHBlZFN0b3JlW10ge1xuICAgIHJldHVybiB0aGlzLl9wYXJlbnRGYWN0b3J5ID8gdGhpcy5fcGFyZW50RmFjdG9yeS5zdGF0ZXMgOiB0aGlzLl9zdGF0ZXM7XG4gIH1cblxuICBwcml2YXRlIF9zdGF0ZXNCeU5hbWU6IFN0YXRlc0J5TmFtZSA9IHt9O1xuXG4gIHB1YmxpYyBnZXQgc3RhdGVzQnlOYW1lKCk6IFN0YXRlc0J5TmFtZSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhcmVudEZhY3RvcnkgPyB0aGlzLl9wYXJlbnRGYWN0b3J5LnN0YXRlc0J5TmFtZSA6IHRoaXMuX3N0YXRlc0J5TmFtZTtcbiAgfVxuXG4gIHByaXZhdGUgX3N0YXRlUGF0aHM6IFBsYWluT2JqZWN0T2Y8c3RyaW5nPiA9IHt9O1xuXG4gIHByaXZhdGUgZ2V0IHN0YXRlUGF0aHMoKTogUGxhaW5PYmplY3RPZjxzdHJpbmc+IHtcbiAgICByZXR1cm4gdGhpcy5fcGFyZW50RmFjdG9yeSA/IHRoaXMuX3BhcmVudEZhY3Rvcnkuc3RhdGVQYXRocyA6IHRoaXMuX3N0YXRlUGF0aHM7XG4gIH1cblxuICBwdWJsaWMgZ2V0UnVudGltZVNlbGVjdG9yQ29udGV4dCA9IG1lbW9pemUoKCkgPT4ge1xuICAgIGNvbnN0IHN0YXRlRmFjdG9yeSA9IHRoaXM7XG4gICAgY29uc3QgY29udGV4dDogUnVudGltZVNlbGVjdG9yQ29udGV4dCA9IHRoaXMuX3BhcmVudEZhY3RvcnlcbiAgICAgID8gdGhpcy5fcGFyZW50RmFjdG9yeS5nZXRSdW50aW1lU2VsZWN0b3JDb250ZXh0KClcbiAgICAgIDoge1xuICAgICAgICAgIGdldFN0YXRlR2V0dGVyKGtleTogc3RyaW5nKSB7XG4gICAgICAgICAgICBjb25zdCBwYXRoID0gc3RhdGVGYWN0b3J5LnN0YXRlUGF0aHNba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBwYXRoID8gcHJvcEdldHRlcihwYXRoLnNwbGl0KCcuJyksIHN0YXRlRmFjdG9yeS5fY29uZmlnKSA6ICgpID0+IHVuZGVmaW5lZDtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGdldFNlbGVjdG9yT3B0aW9ucyhsb2NhbE9wdGlvbnM/OiBTaGFyZWRTZWxlY3Rvck9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNvbnN0IGdsb2JhbFNlbGVjdG9yT3B0aW9ucyA9IHN0YXRlRmFjdG9yeS5fY29uZmlnLnNlbGVjdG9yT3B0aW9ucztcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLmdsb2JhbFNlbGVjdG9yT3B0aW9ucyxcbiAgICAgICAgICAgICAgLi4uKGxvY2FsT3B0aW9ucyB8fCB7fSlcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBjb250ZXh0O1xuICB9KTtcblxuICBwcml2YXRlIHN0YXRpYyBjbG9uZURlZmF1bHRzKGRlZmF1bHRzOiBhbnkpOiBhbnkge1xuICAgIGxldCB2YWx1ZSA9IHt9O1xuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZGVmYXVsdHMpKSB7XG4gICAgICB2YWx1ZSA9IGRlZmF1bHRzLnNsaWNlKCk7XG4gICAgfSBlbHNlIGlmIChpc09iamVjdChkZWZhdWx0cykpIHtcbiAgICAgIHZhbHVlID0geyAuLi5kZWZhdWx0cyB9O1xuICAgIH0gZWxzZSBpZiAoZGVmYXVsdHMgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsdWUgPSBkZWZhdWx0cztcbiAgICB9XG5cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjaGVja1N0YXRlc0FyZVZhbGlkKHN0YXRlQ2xhc3NlczogU3RhdGVDbGFzc0ludGVybmFsW10pOiB2b2lkIHtcbiAgICBzdGF0ZUNsYXNzZXMuZm9yRWFjaChTdG9yZVZhbGlkYXRvcnMuZ2V0VmFsaWRTdGF0ZU1ldGEpO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIG5ldyBzdGF0ZSB0byB0aGUgZ2xvYmFsIGRlZnMuXG4gICAqL1xuICBhZGQoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IE1hcHBlZFN0b3JlW10ge1xuICAgIFN0YXRlRmFjdG9yeS5jaGVja1N0YXRlc0FyZVZhbGlkKHN0YXRlQ2xhc3Nlcyk7XG4gICAgY29uc3QgeyBuZXdTdGF0ZXMgfSA9IHRoaXMuYWRkVG9TdGF0ZXNNYXAoc3RhdGVDbGFzc2VzKTtcbiAgICBpZiAoIW5ld1N0YXRlcy5sZW5ndGgpIHJldHVybiBbXTtcblxuICAgIGNvbnN0IHN0YXRlR3JhcGg6IFN0YXRlS2V5R3JhcGggPSBidWlsZEdyYXBoKG5ld1N0YXRlcyk7XG4gICAgY29uc3Qgc29ydGVkU3RhdGVzOiBzdHJpbmdbXSA9IHRvcG9sb2dpY2FsU29ydChzdGF0ZUdyYXBoKTtcbiAgICBjb25zdCBwYXRoczogUGxhaW5PYmplY3RPZjxzdHJpbmc+ID0gZmluZEZ1bGxQYXJlbnRQYXRoKHN0YXRlR3JhcGgpO1xuICAgIGNvbnN0IG5hbWVHcmFwaDogUGxhaW5PYmplY3RPZjxTdGF0ZUNsYXNzSW50ZXJuYWw+ID0gbmFtZVRvU3RhdGUobmV3U3RhdGVzKTtcbiAgICBjb25zdCBib290c3RyYXBwZWRTdG9yZXM6IE1hcHBlZFN0b3JlW10gPSBbXTtcblxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBzb3J0ZWRTdGF0ZXMpIHtcbiAgICAgIGNvbnN0IHN0YXRlQ2xhc3M6IFN0YXRlQ2xhc3NJbnRlcm5hbCA9IG5hbWVHcmFwaFtuYW1lXTtcbiAgICAgIGNvbnN0IHBhdGg6IHN0cmluZyA9IHBhdGhzW25hbWVdO1xuICAgICAgY29uc3QgbWV0YTogTWV0YURhdGFNb2RlbCA9IHN0YXRlQ2xhc3NbTUVUQV9LRVldITtcblxuICAgICAgdGhpcy5hZGRSdW50aW1lSW5mb1RvTWV0YShtZXRhLCBwYXRoKTtcblxuICAgICAgY29uc3Qgc3RhdGVNYXA6IE1hcHBlZFN0b3JlID0ge1xuICAgICAgICBuYW1lLFxuICAgICAgICBwYXRoLFxuICAgICAgICBpc0luaXRpYWxpc2VkOiBmYWxzZSxcbiAgICAgICAgYWN0aW9uczogbWV0YS5hY3Rpb25zLFxuICAgICAgICBpbnN0YW5jZTogdGhpcy5faW5qZWN0b3IuZ2V0KHN0YXRlQ2xhc3MpLFxuICAgICAgICBkZWZhdWx0czogU3RhdGVGYWN0b3J5LmNsb25lRGVmYXVsdHMobWV0YS5kZWZhdWx0cylcbiAgICAgIH07XG5cbiAgICAgIC8vIGVuc3VyZSBvdXIgc3RvcmUgaGFzbid0IGFscmVhZHkgYmVlbiBhZGRlZFxuICAgICAgLy8gYnV0IGRvbid0IHRocm93IHNpbmNlIGl0IGNvdWxkIGJlIGxhenlcbiAgICAgIC8vIGxvYWRlZCBmcm9tIGRpZmZlcmVudCBwYXRoc1xuICAgICAgaWYgKCF0aGlzLmhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWUsIHBhdGgpKSB7XG4gICAgICAgIGJvb3RzdHJhcHBlZFN0b3Jlcy5wdXNoKHN0YXRlTWFwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZXMucHVzaChzdGF0ZU1hcCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGJvb3RzdHJhcHBlZFN0b3JlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGQgYSBzZXQgb2Ygc3RhdGVzIHRvIHRoZSBzdG9yZSBhbmQgcmV0dXJuIHRoZSBkZWZhdWx0c1xuICAgKi9cbiAgYWRkQW5kUmV0dXJuRGVmYXVsdHMoc3RhdGVDbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSk6IFN0YXRlc0FuZERlZmF1bHRzIHtcbiAgICBjb25zdCBjbGFzc2VzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSA9IHN0YXRlQ2xhc3NlcyB8fCBbXTtcblxuICAgIGNvbnN0IG1hcHBlZFN0b3JlczogTWFwcGVkU3RvcmVbXSA9IHRoaXMuYWRkKGNsYXNzZXMpO1xuICAgIGNvbnN0IGRlZmF1bHRzID0gbWFwcGVkU3RvcmVzLnJlZHVjZShcbiAgICAgIChyZXN1bHQ6IGFueSwgbWFwcGVkU3RvcmU6IE1hcHBlZFN0b3JlKSA9PlxuICAgICAgICBzZXRWYWx1ZShyZXN1bHQsIG1hcHBlZFN0b3JlLnBhdGgsIG1hcHBlZFN0b3JlLmRlZmF1bHRzKSxcbiAgICAgIHt9XG4gICAgKTtcbiAgICByZXR1cm4geyBkZWZhdWx0cywgc3RhdGVzOiBtYXBwZWRTdG9yZXMgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCaW5kIHRoZSBhY3Rpb25zIHRvIHRoZSBoYW5kbGVyc1xuICAgKi9cbiAgY29ubmVjdEFjdGlvbkhhbmRsZXJzKCkge1xuICAgIGlmICh0aGlzLl9jb25uZWN0ZWQpIHJldHVybjtcbiAgICB0aGlzLl9hY3Rpb25zXG4gICAgICAucGlwZShcbiAgICAgICAgZmlsdGVyKChjdHg6IEFjdGlvbkNvbnRleHQpID0+IGN0eC5zdGF0dXMgPT09IEFjdGlvblN0YXR1cy5EaXNwYXRjaGVkKSxcbiAgICAgICAgbWVyZ2VNYXAoKHsgYWN0aW9uIH0pID0+XG4gICAgICAgICAgdGhpcy5pbnZva2VBY3Rpb25zKHRoaXMuX2FjdGlvbnMsIGFjdGlvbiEpLnBpcGUoXG4gICAgICAgICAgICBtYXAoKCkgPT4gPEFjdGlvbkNvbnRleHQ+eyBhY3Rpb24sIHN0YXR1czogQWN0aW9uU3RhdHVzLlN1Y2Nlc3NmdWwgfSksXG4gICAgICAgICAgICBkZWZhdWx0SWZFbXB0eSg8QWN0aW9uQ29udGV4dD57IGFjdGlvbiwgc3RhdHVzOiBBY3Rpb25TdGF0dXMuQ2FuY2VsZWQgfSksXG4gICAgICAgICAgICBjYXRjaEVycm9yKGVycm9yID0+XG4gICAgICAgICAgICAgIG9mKDxBY3Rpb25Db250ZXh0PnsgYWN0aW9uLCBzdGF0dXM6IEFjdGlvblN0YXR1cy5FcnJvcmVkLCBlcnJvciB9KVxuICAgICAgICAgICAgKVxuICAgICAgICAgIClcbiAgICAgICAgKVxuICAgICAgKVxuICAgICAgLnN1YnNjcmliZShjdHggPT4gdGhpcy5fYWN0aW9uUmVzdWx0cy5uZXh0KGN0eCkpO1xuICAgIHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogSW52b2tlIGFjdGlvbnMgb24gdGhlIHN0YXRlcy5cbiAgICovXG4gIGludm9rZUFjdGlvbnMoYWN0aW9ucyQ6IEludGVybmFsQWN0aW9ucywgYWN0aW9uOiBhbnkpIHtcbiAgICBjb25zdCByZXN1bHRzID0gW107XG5cbiAgICBmb3IgKGNvbnN0IG1ldGFkYXRhIG9mIHRoaXMuc3RhdGVzKSB7XG4gICAgICBjb25zdCB0eXBlID0gZ2V0QWN0aW9uVHlwZUZyb21JbnN0YW5jZShhY3Rpb24pITtcbiAgICAgIGNvbnN0IGFjdGlvbk1ldGFzID0gbWV0YWRhdGEuYWN0aW9uc1t0eXBlXTtcblxuICAgICAgaWYgKGFjdGlvbk1ldGFzKSB7XG4gICAgICAgIGZvciAoY29uc3QgYWN0aW9uTWV0YSBvZiBhY3Rpb25NZXRhcykge1xuICAgICAgICAgIGNvbnN0IHN0YXRlQ29udGV4dCA9IHRoaXMuX3N0YXRlQ29udGV4dEZhY3RvcnkuY3JlYXRlU3RhdGVDb250ZXh0KG1ldGFkYXRhKTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IG1ldGFkYXRhLmluc3RhbmNlW2FjdGlvbk1ldGEuZm5dKHN0YXRlQ29udGV4dCwgYWN0aW9uKTtcblxuICAgICAgICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHtcbiAgICAgICAgICAgICAgcmVzdWx0ID0gZnJvbShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocmVzdWx0IGluc3RhbmNlb2YgT2JzZXJ2YWJsZSkge1xuICAgICAgICAgICAgICBpZiAoYWN0aW9uTWV0YS5vcHRpb25zLmNhbmNlbFVuY29tcGxldGVkKSB7XG4gICAgICAgICAgICAgICAgLy8gdG9kbzogb2ZBY3Rpb25EaXNwYXRjaGVkIHNob3VsZCBiZSB1c2VkIHdpdGggYWN0aW9uIGNsYXNzXG4gICAgICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnBpcGUoXG4gICAgICAgICAgICAgICAgICB0YWtlVW50aWwoYWN0aW9ucyQucGlwZShvZkFjdGlvbkRpc3BhdGNoZWQoYWN0aW9uIGFzIGFueSkpKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IG9mKHt9KS5waXBlKHNoYXJlUmVwbGF5KCkpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXN1bHRzLnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICByZXN1bHRzLnB1c2godGhyb3dFcnJvcihlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKCFyZXN1bHRzLmxlbmd0aCkge1xuICAgICAgcmVzdWx0cy5wdXNoKG9mKHt9KSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZvcmtKb2luKHJlc3VsdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBhZGRUb1N0YXRlc01hcChcbiAgICBzdGF0ZUNsYXNzZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdXG4gICk6IHsgbmV3U3RhdGVzOiBTdGF0ZUNsYXNzSW50ZXJuYWxbXSB9IHtcbiAgICBjb25zdCBuZXdTdGF0ZXM6IFN0YXRlQ2xhc3NJbnRlcm5hbFtdID0gW107XG4gICAgY29uc3Qgc3RhdGVzTWFwOiBTdGF0ZXNCeU5hbWUgPSB0aGlzLnN0YXRlc0J5TmFtZTtcblxuICAgIGZvciAoY29uc3Qgc3RhdGVDbGFzcyBvZiBzdGF0ZUNsYXNzZXMpIHtcbiAgICAgIGNvbnN0IHN0YXRlTmFtZTogc3RyaW5nID0gU3RvcmVWYWxpZGF0b3JzLmNoZWNrU3RhdGVOYW1lSXNVbmlxdWUoc3RhdGVDbGFzcywgc3RhdGVzTWFwKTtcbiAgICAgIGNvbnN0IHVubW91bnRlZFN0YXRlID0gIXN0YXRlc01hcFtzdGF0ZU5hbWVdO1xuICAgICAgaWYgKHVubW91bnRlZFN0YXRlKSB7XG4gICAgICAgIG5ld1N0YXRlcy5wdXNoKHN0YXRlQ2xhc3MpO1xuICAgICAgICBzdGF0ZXNNYXBbc3RhdGVOYW1lXSA9IHN0YXRlQ2xhc3M7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHsgbmV3U3RhdGVzIH07XG4gIH1cblxuICBwcml2YXRlIGFkZFJ1bnRpbWVJbmZvVG9NZXRhKG1ldGE6IE1ldGFEYXRhTW9kZWwsIHBhdGg6IHN0cmluZyk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGVQYXRoc1ttZXRhLm5hbWUhXSA9IHBhdGg7XG4gICAgLy8gVE9ETzogdjQgLSB3ZSBwbGFuIHRvIGdldCByaWQgb2YgdGhlIHBhdGggcHJvcGVydHkgYmVjYXVzZSBpdCBpcyBub24tZGV0ZXJtaW5pc3RpY1xuICAgIC8vIHdlIGNhbiBkbyB0aGlzIHdoZW4gd2UgZ2V0IHJpZCBvZiB0aGUgaW5jb3JyZWN0bHkgZXhwb3NlZCBnZXRTdG9yZU1ldGFkYXRhXG4gICAgLy8gV2Ugd2lsbCBuZWVkIHRvIGNvbWUgdXAgd2l0aCBhbiBhbHRlcm5hdGl2ZSBpbiB2NCBiZWNhdXNlIHRoaXMgaXMgdXNlZCBieSBtYW55IHBsdWdpbnNcbiAgICBtZXRhLnBhdGggPSBwYXRoO1xuICB9XG5cbiAgLyoqXG4gICAqIEBkZXNjcmlwdGlvblxuICAgKiB0aGUgbWV0aG9kIGNoZWNrcyBpZiB0aGUgc3RhdGUgaGFzIGFscmVhZHkgYmVlbiBhZGRlZCB0byB0aGUgdHJlZVxuICAgKiBhbmQgY29tcGxldGVkIHRoZSBsaWZlIGN5Y2xlXG4gICAqIEBwYXJhbSBuYW1lXG4gICAqIEBwYXJhbSBwYXRoXG4gICAqL1xuICBwcml2YXRlIGhhc0JlZW5Nb3VudGVkQW5kQm9vdHN0cmFwcGVkKG5hbWU6IHN0cmluZywgcGF0aDogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgY29uc3QgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlOiBib29sZWFuID1cbiAgICAgIGdldFZhbHVlKHRoaXMuX2luaXRpYWxTdGF0ZSwgcGF0aCkgIT09IHVuZGVmaW5lZDtcbiAgICByZXR1cm4gdGhpcy5zdGF0ZXNCeU5hbWVbbmFtZV0gJiYgdmFsdWVJc0Jvb3RzdHJhcHBlZEluSW5pdGlhbFN0YXRlO1xuICB9XG59XG4iXX0=