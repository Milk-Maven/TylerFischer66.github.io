{"version":3,"sources":["../../../node_modules/tslib/tslib.es6.js","ng://@ngxs/store/src/configs/messages.config.ts","ng://@ngxs/store/src/execution/dispatch-outside-zone-ngxs-execution-strategy.ts","ng://@ngxs/store/src/symbols.ts","ng://@ngxs/store/src/execution/symbols.ts","ng://@ngxs/store/src/utils/utils.ts","ng://@ngxs/store/src/internal/internals.ts","ng://@ngxs/store/src/operators/of-action.ts","ng://@ngxs/store/src/operators/leave-ngxs.ts","ng://@ngxs/store/src/execution/internal-ngxs-execution-strategy.ts","ng://@ngxs/store/src/actions-stream.ts","ng://@ngxs/store/src/utils/compose.ts","ng://@ngxs/store/src/internal/state-stream.ts","ng://@ngxs/store/src/plugin-manager.ts","ng://@ngxs/store/src/internal/dispatcher.ts","ng://@ngxs/store/src/utils/freeze.ts","ng://@ngxs/store/src/host-environment/host-environment.ts","ng://@ngxs/store/src/internal/config-validator.ts","ng://@ngxs/store/src/internal/state-operations.ts","ng://@ngxs/store/src/internal/state-context-factory.ts","ng://@ngxs/store/src/internal/state-operators.ts","ng://@ngxs/store/src/utils/store-validators.ts","ng://@ngxs/store/src/internal/state-factory.ts","ng://@ngxs/store/src/internal/lifecycle-state-manager.ts","ng://@ngxs/store/src/utils/selector-utils.ts","ng://@ngxs/store/src/store.ts","ng://@ngxs/store/src/decorators/select/select-factory.ts","ng://@ngxs/store/src/actions/actions.ts","ng://@ngxs/store/src/ivy/ivy-enabled-in-dev-mode.ts","ng://@ngxs/store/src/modules/ngxs-root.module.ts","ng://@ngxs/store/src/modules/ngxs-feature.module.ts","ng://@ngxs/store/src/module.ts","ng://@ngxs/store/src/ivy/ensure-state-class-is-injectable.ts","ng://@ngxs/store/src/decorators/select/symbols.ts","ng://@ngxs/store/src/execution/noop-ngxs-execution-strategy.ts","ng://@ngxs/store/src/state-token/state-token.ts","ng://@ngxs/store/src/decorators/action.ts","ng://@ngxs/store/src/decorators/select/select.ts","ng://@ngxs/store/src/decorators/selector/selector.ts","ng://@ngxs/store/src/decorators/selector-options.ts","ng://@ngxs/store/src/decorators/state.ts","ng://@ngxs/store/src/public_to_deprecate.ts"],"names":["extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__extends","__","this","constructor","prototype","create","__assign","assign","t","s","i","n","arguments","length","call","apply","__values","o","m","Symbol","iterator","next","value","done","__read","r","e","ar","push","error","__spread","concat","STATE_NAME","STATE_UNIQUE","STATE_NAME_PROPERTY","STATE_DECORATOR","INCORRECT_PRODUCTION","INCORRECT_DEVELOPMENT","SELECT_FACTORY_NOT_CONNECTED","ACTION_DECORATOR","SELECTOR_DECORATOR","ZONE_WARNING","PATCHING_ARRAY","PATCHING_PRIMITIVE","UNDECORATED_STATE_IN_IVY","CONFIG_MESSAGES","_a","VALIDATION_CODE","name","current","newName","oldName","DispatchOutsideZoneNgxsExecutionStrategy","_ngZone","_platformId","verifyZoneIsNotNooped","enter","func","isPlatformServer","runInsideAngular","runOutsideAngular","leave","NgZone","isInAngularZone","run","ngZone","console","warn","Injectable","Inject","args","PLATFORM_ID","ROOT_STATE_TOKEN","InjectionToken","FEATURE_STATE_TOKEN","NGXS_PLUGINS","NG_TEST_MODE","NG_DEV_MODE","META_KEY","META_OPTIONS_KEY","SELECTOR_META_KEY","NgxsConfig","defaultsState","selectorOptions","injectContainerState","suppressErrors","compatibility","strictContentSecurityPolicy","executionStrategy","previousValue","currentValue","firstChange","NGXS_EXECUTION_STRATEGY","getActionTypeFromInstance","action","type","setValue","obj","prop","val","split","lastIndex","reduce","acc","part","index","isArray","slice","getValue","ensureStoreMetadata","target","defaultMetadata_1","actions","defaults","path","makeRootSelector","context","getStateGetter","children","defineProperty","getStoreMetadata","ensureSelectorMetadata","originalFn","containerClass","selectorName","getSelectorOptions","getSelectorMetadata","propGetter","paths","config","copyOfPaths","compliantPropGetter","segments","seg","l","expr","Function","fastPropGetter","getStateDiffChanges","mappedStore","diff","currentAppState","newAppState","NgxsSimpleChange","isInitialised","ofActionDispatched","allowedTypes","_i","ofActionOperator","statuses","mapOperator","mapAction","allowedMap","filterMap","klass","allowedStatusMap","status","createAllowedStatusesMap","pipe","allowedStatuses","filter","ctx","actionType","typeMatch","statusMatch","filterStatus","mapActionResult","map","result","successful","canceled","leaveNgxs","ngxsExecutionStrategy","source","Observable","sink","subscribe","complete","InternalNgxsExecutionStrategy","_executionStrategy","OrderedSubject","_this","_super","_itemQueue","_busyPushingNext","tslib_1.__extends","unshift","nextValue","pop","Subject","InternalActions","Actions","internalActions$","internalExecutionStrategy","observer","childSubscription","add","compose","funcs","curr","shift","nextArgs","StateStream","BehaviorSubject","PluginManager","_parentManager","_pluginHandlers","plugins","registerHandlers","pluginHandlers","getPluginHandlers","rootPlugins","plugin","handle","bind","decorators","Optional","SkipSelf","InternalDispatchedActionResults","InternalDispatcher","_errorHandler","_actions","_actionResults","_pluginManager","_stateStream","_ngxsExecutionStrategy","dispatch","actionOrActions","dispatchByEvents","handleError","of","forkJoin","dispatchSingle","prevState","nextState","nextAction","actionResult$","getActionResultStream","createDispatchObservable","shareReplay","take","exhaustMap","throwError","EMPTY","ErrorHandler","deepFreeze","freeze","oIsFunction","hasOwnProp","getOwnPropertyNames","forEach","isFrozen","HostEnvironment","isDevMode","isTestMode","ConfigValidator","_host","_config","developmentMode","verifyDevMode","isIncorrectProduction","MESSAGES","CODE","isIncorrectDevelopment","InternalStateOperations","_dispatcher","configValidator","getRootStateOperations","rootStateOperations","getState","setState","newState","ensureStateAndActionsAreImmutable","root","frozenValue","setStateToTheCurrentWithNew","results","stateOperations","currentState","StateContextFactory","_internalStateOperations","createStateContext","setStateValue","newValue","instance","ngxsOnChanges","change","setStateFromOperator","stateOperator","patchState","existingState","Error","key","simplePatch","StoreValidators","stateNameErrorMessage","checkCorrectStateName","stateNameRegex","test","checkStateNameIsUnique","state","statesByName","stateName","getValidStateMeta","meta","RegExp","StateFactory","_injector","_parentFactory","_stateContextFactory","_initialState","_connected","_states","_statesByName","_statePaths","getRuntimeSelectorContext","memoize","stateFactory","statePaths","localOptions","globalSelectorOptions","states","cloneDefaults","undefined","checkStatesAreValid","stateClasses","newStates","addToStatesMap","graph","sorted","visited","visit","stateGraph","findName","stateClass","find","g","buildGraph","sortedStates","ancestors","dep","indexOf","join","keys","k","reverse","newObj","child","keyToFind","parent_1","parent_2","findFullParentPath","nameGraph","bootstrappedStores","sortedStates_1","tslib_1.__values","sortedStates_1_1","name_1","addRuntimeInfoToMeta","stateMap","get","hasBeenMountedAndBootstrapped","addAndReturnDefaults","classes","mappedStores","connectActionHandlers","mergeMap","invokeActions","defaultIfEmpty","catchError","actions$","_c","_d","metadata","actionMetas","actionMetas_1","actionMetas_1_1","actionMeta","stateContext","fn","Promise","from","options","cancelUncompleted","takeUntil","statesMap","stateClasses_1","stateClasses_1_1","valueIsBootstrappedInInitialState","Injector","INITIAL_STATE_TOKEN","LifecycleStateManager","internalStateOperations","stateContextFactory","bootstrapper","ngxsBootstrap","tap","invokeInit","appBootstrapped$","appBootstrapped","invokeBootstrap","mappedStores_1","mappedStores_1_1","firstDiffChange","ngxsOnInit","getStateContext","mappedStores_2","mappedStores_2_1","ngxsAfterBootstrap","NgxsBootstrapper","selectorOptionsMetaAccessor","getOptions","defineOptions","createSelector","selectors","creationMetadata","memoizedFn","returnValue","innerMemoizedFn","selectorMetaData","getExplicitSelectorOptions","selectorMetaDataClone","explicitOptions","getLocalSelectorOptions","setupSelectorMetadata","localSelectorOptions","argumentSelectorFunctions","selectorsToApply","canInjectContainerState","getSelectorsToApply","selector","getRootSelectorFactory","factory","getRuntimeSelectorInfo","rootState","argFn","ex","TypeError","Store","_internalExecutionStrategy","_stateFactory","initialStateValue","initStateStream","event","select","selectorFn","getStoreBoundSelectorFn","err","distinctUntilChanged","selectOnce","selectSnapshot","snapshot","reset","makeSelectorFn","storeValues","SelectFactory","store","InitState","UpdateState","addedStates","_ivyEnabledInDevMode$","ReplaySubject","NgxsRootModule","_store","_select","lifecycleStateManager","ng","_ivyEnabledInDevMode","probe","coreTokens","setIvyEnabledInDevMode","NgModule","NgxsFeatureModule","flattenedStates","flattenStates","total","values","NgxsModule","forRoot","ngModule","providers","ngxsTokenProviders","forFeature","provide","multi","useValue","isAngularInTestMode","useClass","ROOT_OPTIONS","useFactory","ngxsConfigFactory","deps","APP_BOOTSTRAP_LISTENER","appBootstrapListenerFactory","getInitialState","NGXS_STATE_CONTEXT_FACTORY","useExisting","NGXS_STATE_FACTORY","bootstrap","InitialState","ensureStateClassIsInjectable","asObservable","Éµprov","DOLLAR_CHAR_CODE","createSelectorFn","rawSelector","lastCharIndex","charCodeAt","removeDollarAtTheEnd","NoopNgxsExecutionStrategy","StateToken","runtimeContext","getName","toString","actions_1","actions_1_1","selectorId","defineProperties","writable","enumerable","configurable","createSelectObservable","descriptor","newDescriptor","methodName","inheritedStateClass","getPrototypeOf","optionsWithInheritance","inheritanceOptions","getStateOptions","params","inheritedMeta","mutateMetaData","action1","type1","action2","ensureSelectorMetadataInternal","ensureStoreMetadataInternal","getSelectorMetadataInternal","getStoreMetadataInternal"],"mappings":"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","sourcesContent":["/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation. All rights reserved.\r\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use\r\nthis file except in compliance with the License. You may obtain a copy of the\r\nLicense at http://www.apache.org/licenses/LICENSE-2.0\r\n\r\nTHIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\r\nKIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED\r\nWARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,\r\nMERCHANTABLITY OR NON-INFRINGEMENT.\r\n\r\nSee the Apache Version 2.0 License for specific language governing permissions\r\nand limitations under the License.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nexport function __extends(d, b) {\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nexport var __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nexport function __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nexport function __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nexport function __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nexport function __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nexport function __awaiter(thisArg, _arguments, P, generator) {\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nexport function __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nexport function __exportStar(m, exports) {\r\n    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\r\n}\r\n\r\nexport function __values(o) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator], i = 0;\r\n    if (m) return m.call(o);\r\n    return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n}\r\n\r\nexport function __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\nexport function __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\nexport function __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n};\r\n\r\nexport function __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nexport function __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nexport function __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nexport function __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nexport function __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nexport function __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];\r\n    result.default = mod;\r\n    return result;\r\n}\r\n\r\nexport function __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n","export enum VALIDATION_CODE {\n  STATE_NAME = 'STATE_NAME',\n  STATE_UNIQUE = 'STATE_UNIQUE',\n  STATE_NAME_PROPERTY = 'STATE_NAME_PROPERTY',\n  STATE_DECORATOR = 'STATE_DECORATOR',\n  INCORRECT_PRODUCTION = 'INCORRECT_PRODUCTION',\n  INCORRECT_DEVELOPMENT = 'INCORRECT_DEVELOPMENT',\n  SELECT_FACTORY_NOT_CONNECTED = 'SELECT_FACTORY_NOT_CONNECTED',\n  ACTION_DECORATOR = 'ACTION_DECORATOR',\n  SELECTOR_DECORATOR = 'SELECTOR_DECORATOR',\n  ZONE_WARNING = 'ZONE_WARNING',\n  PATCHING_ARRAY = 'PATCHING_ARRAY',\n  PATCHING_PRIMITIVE = 'PATCHING_PRIMITIVE',\n  UNDECORATED_STATE_IN_IVY = 'UNDECORATED_STATE_IN_IVY'\n}\n\nexport const CONFIG_MESSAGES = {\n  [VALIDATION_CODE.STATE_NAME]: (name: string) =>\n    `${name} is not a valid state name. It needs to be a valid object property name.`,\n  [VALIDATION_CODE.STATE_NAME_PROPERTY]: () => `States must register a 'name' property`,\n  [VALIDATION_CODE.STATE_UNIQUE]: (current: string, newName: string, oldName: string) =>\n    `State name '${current}' from ${newName} already exists in ${oldName}`,\n  [VALIDATION_CODE.STATE_DECORATOR]: () => 'States must be decorated with @State() decorator',\n  [VALIDATION_CODE.INCORRECT_PRODUCTION]: () =>\n    'Angular is running in production mode but NGXS is still running in the development mode!\\n' +\n    'Please set developmentMode to false on the NgxsModule options when in production mode.\\n' +\n    'NgxsModule.forRoot(states, { developmentMode: !environment.production })',\n  [VALIDATION_CODE.INCORRECT_DEVELOPMENT]: () =>\n    'RECOMMENDATION: Set developmentMode to true on the NgxsModule when Angular is running in development mode.\\n' +\n    'NgxsModule.forRoot(states, { developmentMode: !environment.production })',\n  [VALIDATION_CODE.SELECT_FACTORY_NOT_CONNECTED]: () =>\n    'You have forgotten to import the NGXS module!',\n  [VALIDATION_CODE.ACTION_DECORATOR]: () =>\n    '@Action() decorator cannot be used with static methods',\n  [VALIDATION_CODE.SELECTOR_DECORATOR]: () => 'Selectors only work on methods',\n  [VALIDATION_CODE.ZONE_WARNING]: () =>\n    'Your application was bootstrapped with nooped zone and your execution strategy requires an actual NgZone!\\n' +\n    'Please set the value of the executionStrategy property to NoopNgxsExecutionStrategy.\\n' +\n    'NgxsModule.forRoot(states, { executionStrategy: NoopNgxsExecutionStrategy })',\n  [VALIDATION_CODE.PATCHING_ARRAY]: () => 'Patching arrays is not supported.',\n  [VALIDATION_CODE.PATCHING_PRIMITIVE]: () => 'Patching primitives is not supported.',\n  [VALIDATION_CODE.UNDECORATED_STATE_IN_IVY]: (name: string) =>\n    `'${name}' class should be decorated with @Injectable() right after the @State() decorator`\n};\n","import { Inject, Injectable, NgZone, PLATFORM_ID } from '@angular/core';\nimport { isPlatformServer } from '@angular/common';\n\nimport { NgxsExecutionStrategy } from './symbols';\nimport { CONFIG_MESSAGES, VALIDATION_CODE } from '../configs/messages.config';\n\n@Injectable()\nexport class DispatchOutsideZoneNgxsExecutionStrategy implements NgxsExecutionStrategy {\n  constructor(private _ngZone: NgZone, @Inject(PLATFORM_ID) private _platformId: string) {\n    this.verifyZoneIsNotNooped(this._ngZone);\n  }\n\n  enter<T>(func: () => T): T {\n    if (isPlatformServer(this._platformId)) {\n      return this.runInsideAngular(func);\n    }\n    return this.runOutsideAngular(func);\n  }\n\n  leave<T>(func: () => T): T {\n    return this.runInsideAngular(func);\n  }\n\n  private runInsideAngular<T>(func: () => T): T {\n    if (NgZone.isInAngularZone()) {\n      return func();\n    }\n    return this._ngZone.run(func);\n  }\n\n  private runOutsideAngular<T>(func: () => T): T {\n    if (NgZone.isInAngularZone()) {\n      return this._ngZone.runOutsideAngular(func);\n    }\n    return func();\n  }\n\n  private verifyZoneIsNotNooped(ngZone: NgZone): void {\n    // `NoopNgZone` is not exposed publicly as it doesn't expect\n    // to be used outside of the core Angular code, thus we just have\n    // to check if the zone doesn't extend or instanceof `NgZone`\n    if (ngZone instanceof NgZone) {\n      return;\n    }\n\n    console.warn(CONFIG_MESSAGES[VALIDATION_CODE.ZONE_WARNING]());\n  }\n}\n","import { Injectable, InjectionToken, Type } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nimport { PlainObject, StateClass } from '@ngxs/store/internals';\nimport { SharedSelectorOptions, Callback } from './internal/internals';\nimport { NgxsExecutionStrategy } from './execution/symbols';\nimport { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';\nimport { StateToken } from './state-token/state-token';\n\nexport const ROOT_STATE_TOKEN = new InjectionToken<any>('ROOT_STATE_TOKEN');\nexport const FEATURE_STATE_TOKEN = new InjectionToken<any>('FEATURE_STATE_TOKEN');\nexport const NGXS_PLUGINS = new InjectionToken('NGXS_PLUGINS');\nexport const NG_TEST_MODE = new InjectionToken<Callback<boolean>>('NG_TEST_MODE');\nexport const NG_DEV_MODE = new InjectionToken<Callback<boolean>>('NG_DEV_MODE');\n\nexport const META_KEY = 'NGXS_META';\nexport const META_OPTIONS_KEY = 'NGXS_OPTIONS_META';\nexport const SELECTOR_META_KEY = 'NGXS_SELECTOR_META';\n\nexport type NgxsLifeCycle = Partial<NgxsOnChanges> &\n  Partial<NgxsOnInit> &\n  Partial<NgxsAfterBootstrap>;\n\nexport type NgxsPluginFn = (state: any, mutation: any, next: NgxsNextPluginFn) => any;\n\n/**\n * The NGXS config settings.\n */\n@Injectable()\nexport class NgxsConfig {\n  /**\n   * Run in development mode. This will add additional debugging features:\n   * - Object.freeze on the state and actions to guarantee immutability\n   * (default: false)\n   */\n  developmentMode: boolean;\n  compatibility: {\n    /**\n     * Support a strict Content Security Policy.\n     * This will circumvent some optimisations that violate a strict CSP through the use of `new Function(...)`.\n     * (default: false)\n     */\n    strictContentSecurityPolicy: boolean;\n  };\n  /**\n   * Determines the execution context to perform async operations inside. An implementation can be\n   * provided to override the default behaviour where the async operations are run\n   * outside Angular's zone but all observable behaviours of NGXS are run back inside Angular's zone.\n   * These observable behaviours are from:\n   *   `@Select(...)`, `store.select(...)`, `actions.subscribe(...)` or `store.dispatch(...).subscribe(...)`\n   * Every `zone.run` causes Angular to run change detection on the whole tree (`app.tick()`) so of your\n   * application doesn't rely on zone.js running change detection then you can switch to the\n   * `NoopNgxsExecutionStrategy` that doesn't interact with zones.\n   * (default: null)\n   */\n  executionStrategy: Type<NgxsExecutionStrategy>;\n  /**\n   * Defining the default state before module initialization\n   * This is convenient if we need to create a define our own set of states.\n   * @deprecated will be removed after v4\n   * (default: {})\n   */\n  defaultsState: PlainObject = {};\n  /**\n   * Defining shared selector options\n   */\n  selectorOptions: SharedSelectorOptions = {\n    injectContainerState: true, // TODO: default is true in v3, will change in v4\n    suppressErrors: true // TODO: default is true in v3, will change in v4\n  };\n\n  constructor() {\n    this.compatibility = {\n      strictContentSecurityPolicy: false\n    };\n    this.executionStrategy = DispatchOutsideZoneNgxsExecutionStrategy;\n  }\n}\n\nexport type StateOperator<T> = (existing: Readonly<T>) => T;\n\n/**\n * State context provided to the actions in the state.\n */\nexport interface StateContext<T> {\n  /**\n   * Get the current state.\n   */\n  getState(): T;\n\n  /**\n   * Reset the state to a new value.\n   */\n  setState(val: T | StateOperator<T>): T;\n\n  /**\n   * Patch the existing state with the provided value.\n   */\n  patchState(val: Partial<T>): T;\n\n  /**\n   * Dispatch a new action and return the dispatched observable.\n   */\n  dispatch(actions: any | any[]): Observable<void>;\n}\n\nexport type NgxsNextPluginFn = (state: any, mutation: any) => any;\n\n/**\n * Plugin interface\n */\nexport interface NgxsPlugin {\n  /**\n   * Handle the state/action before its submitted to the state handlers.\n   */\n  handle(state: any, action: any, next: NgxsNextPluginFn): any;\n}\n\n/**\n * Options that can be provided to the store.\n */\nexport interface StoreOptions<T> {\n  /**\n   * Name of the state. Required.\n   */\n  name: string | StateToken<T>;\n\n  /**\n   * Default values for the state. If not provided, uses empty object.\n   */\n  defaults?: T;\n\n  /**\n   * Sub states for the given state.\n   */\n  children?: StateClass[];\n}\n\n/**\n * Represents a basic change from a previous to a new value for a single state instance.\n * Passed as a value in a NgxsSimpleChanges object to the ngxsOnChanges hook.\n */\nexport class NgxsSimpleChange<T = any> {\n  constructor(\n    public readonly previousValue: T,\n    public readonly currentValue: T,\n    public readonly firstChange: boolean\n  ) {}\n}\n\n/**\n * On init interface\n */\nexport interface NgxsOnInit {\n  ngxsOnInit(ctx?: StateContext<any>): void | any;\n}\n\n/**\n * On change interface\n */\nexport interface NgxsOnChanges {\n  ngxsOnChanges(change: NgxsSimpleChange): void;\n}\n\n/**\n * After bootstrap interface\n */\nexport interface NgxsAfterBootstrap {\n  ngxsAfterBootstrap(ctx?: StateContext<any>): void;\n}\n\nexport type NgxsModuleOptions = Partial<NgxsConfig>;\n","import { InjectionToken } from '@angular/core';\n\n/*\n * Internal execution strategy injection token\n */\nexport const NGXS_EXECUTION_STRATEGY = new InjectionToken<NgxsExecutionStrategy>(\n  'NGXS_EXECUTION_STRATEGY'\n);\n\n/*\n * Execution strategy interface\n */\nexport interface NgxsExecutionStrategy {\n  enter<T>(func: () => T): T;\n  leave<T>(func: () => T): T;\n}\n","/**\n * Returns the type from an action instance/class.\n * @ignore\n */\nexport function getActionTypeFromInstance(action: any): string | undefined {\n  if (action.constructor && action.constructor.type) {\n    return action.constructor.type;\n  }\n\n  return action.type;\n}\n\n/**\n * Matches a action\n * @ignore\n */\nexport function actionMatcher(action1: any) {\n  const type1 = getActionTypeFromInstance(action1);\n\n  return function(action2: any) {\n    return type1 === getActionTypeFromInstance(action2);\n  };\n}\n\n/**\n * Set a deeply nested value. Example:\n *\n *   setValue({ foo: { bar: { eat: false } } },\n *      'foo.bar.eat', true) //=> { foo: { bar: { eat: true } } }\n *\n * While it traverses it also creates new objects from top down.\n *\n * @ignore\n */\nexport const setValue = (obj: any, prop: string, val: any) => {\n  obj = { ...obj };\n\n  const split = prop.split('.');\n  const lastIndex = split.length - 1;\n\n  split.reduce((acc, part, index) => {\n    if (index === lastIndex) {\n      acc[part] = val;\n    } else {\n      acc[part] = Array.isArray(acc[part]) ? acc[part].slice() : { ...acc[part] };\n    }\n\n    return acc && acc[part];\n  }, obj);\n\n  return obj;\n};\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nexport const getValue = (obj: any, prop: string): any =>\n  prop.split('.').reduce((acc: any, part: string) => acc && acc[part], obj);\n","import { PlainObjectOf, StateClass } from '@ngxs/store/internals';\nimport { Observable } from 'rxjs';\n\nimport {\n  META_KEY,\n  META_OPTIONS_KEY,\n  NgxsConfig,\n  NgxsSimpleChange,\n  SELECTOR_META_KEY,\n  StoreOptions\n} from '../symbols';\nimport { ActionHandlerMetaData } from '../actions/symbols';\nimport { getValue } from '../utils/utils';\n\n// inspired from https://stackoverflow.com/a/43674389\nexport interface StateClassInternal<T = any, U = any> extends StateClass<T> {\n  [META_KEY]?: MetaDataModel;\n  [META_OPTIONS_KEY]?: StoreOptions<U>;\n}\n\nexport type StateKeyGraph = PlainObjectOf<string[]>;\nexport type StatesByName = PlainObjectOf<StateClassInternal>;\n\nexport interface StateOperations<T> {\n  getState(): T;\n\n  setState(val: T): T;\n\n  dispatch(actions: any | any[]): Observable<void>;\n}\n\nexport interface MetaDataModel {\n  name: string | null;\n  actions: PlainObjectOf<ActionHandlerMetaData[]>;\n  defaults: any;\n  path: string | null;\n  makeRootSelector: SelectorFactory | null;\n  children?: StateClassInternal[];\n}\n\nexport interface RuntimeSelectorContext {\n  getStateGetter(key: any): (state: any) => any;\n  getSelectorOptions(localOptions?: SharedSelectorOptions): SharedSelectorOptions;\n}\n\nexport type SelectFromRootState = (rootState: any) => any;\nexport type SelectorFactory = (runtimeContext: RuntimeSelectorContext) => SelectFromRootState;\n\nexport interface SharedSelectorOptions {\n  injectContainerState?: boolean;\n  suppressErrors?: boolean;\n}\n\nexport interface SelectorMetaDataModel {\n  makeRootSelector: SelectorFactory | null;\n  originalFn: Function | null;\n  containerClass: any;\n  selectorName: string | null;\n  getSelectorOptions: () => SharedSelectorOptions;\n}\n\nexport interface MappedStore {\n  name: string;\n  isInitialised: boolean;\n  actions: PlainObjectOf<ActionHandlerMetaData[]>;\n  defaults: any;\n  instance: any;\n  path: string;\n}\n\nexport interface StatesAndDefaults {\n  defaults: any;\n  states: MappedStore[];\n}\n\nexport type Callback<T = any, V = any> = (...args: V[]) => T;\n\nexport interface RootStateDiff<T> {\n  currentAppState: T;\n  newAppState: T;\n}\n\n/**\n * Ensures metadata is attached to the class and returns it.\n *\n * @ignore\n */\nexport function ensureStoreMetadata(target: StateClassInternal): MetaDataModel {\n  if (!target.hasOwnProperty(META_KEY)) {\n    const defaultMetadata: MetaDataModel = {\n      name: null,\n      actions: {},\n      defaults: {},\n      path: null,\n      makeRootSelector(context: RuntimeSelectorContext) {\n        return context.getStateGetter(defaultMetadata.name);\n      },\n      children: []\n    };\n\n    Object.defineProperty(target, META_KEY, { value: defaultMetadata });\n  }\n  return getStoreMetadata(target);\n}\n\n/**\n * Get the metadata attached to the state class if it exists.\n *\n * @ignore\n */\nexport function getStoreMetadata(target: StateClassInternal): MetaDataModel {\n  return target[META_KEY]!;\n}\n\n/**\n * Ensures metadata is attached to the selector and returns it.\n *\n * @ignore\n */\nexport function ensureSelectorMetadata(target: Function): SelectorMetaDataModel {\n  if (!target.hasOwnProperty(SELECTOR_META_KEY)) {\n    const defaultMetadata: SelectorMetaDataModel = {\n      makeRootSelector: null,\n      originalFn: null,\n      containerClass: null,\n      selectorName: null,\n      getSelectorOptions: () => ({})\n    };\n\n    Object.defineProperty(target, SELECTOR_META_KEY, { value: defaultMetadata });\n  }\n\n  return getSelectorMetadata(target);\n}\n\n/**\n * Get the metadata attached to the selector if it exists.\n *\n * @ignore\n */\nexport function getSelectorMetadata(target: any): SelectorMetaDataModel {\n  return target[SELECTOR_META_KEY];\n}\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * Note: This is not as fast as the `fastPropGetter` but is strict Content Security Policy compliant.\n * See perf hit: https://jsperf.com/fast-value-getter-given-path/1\n *\n * @ignore\n */\nfunction compliantPropGetter(paths: string[]): (x: any) => any {\n  const copyOfPaths = paths.slice();\n  return obj => copyOfPaths.reduce((acc: any, part: string) => acc && acc[part], obj);\n}\n\n/**\n * The generated function is faster than:\n * - pluck (Observable operator)\n * - memoize\n *\n * @ignore\n */\nfunction fastPropGetter(paths: string[]): (x: any) => any {\n  const segments = paths;\n  let seg = 'store.' + segments[0];\n  let i = 0;\n  const l = segments.length;\n\n  let expr = seg;\n  while (++i < l) {\n    expr = expr + ' && ' + (seg = seg + '.' + segments[i]);\n  }\n\n  const fn = new Function('store', 'return ' + expr + ';');\n\n  return <(x: any) => any>fn;\n}\n\n/**\n * Get a deeply nested value. Example:\n *\n *    getValue({ foo: bar: [] }, 'foo.bar') //=> []\n *\n * @ignore\n */\nexport function propGetter(paths: string[], config: NgxsConfig) {\n  if (config && config.compatibility && config.compatibility.strictContentSecurityPolicy) {\n    return compliantPropGetter(paths);\n  } else {\n    return fastPropGetter(paths);\n  }\n}\n\n/**\n * Given an array of states, it will return a object graph. Example:\n *    const states = [\n *      Cart,\n *      CartSaved,\n *      CartSavedItems\n *    ]\n *\n * would return:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * @ignore\n */\nexport function buildGraph(stateClasses: StateClassInternal[]): StateKeyGraph {\n  const findName = (stateClass: StateClassInternal) => {\n    const meta = stateClasses.find(g => g === stateClass);\n    if (!meta) {\n      throw new Error(\n        `Child state not found: ${stateClass}. \\r\\nYou may have forgotten to add states to module`\n      );\n    }\n\n    return meta[META_KEY]!.name!;\n  };\n\n  return stateClasses.reduce<StateKeyGraph>(\n    (result: StateKeyGraph, stateClass: StateClassInternal) => {\n      const { name, children } = stateClass[META_KEY]!;\n      result[name!] = (children || []).map(findName);\n      return result;\n    },\n    {}\n  );\n}\n\n/**\n * Given a states array, returns object graph\n * returning the name and state metadata. Example:\n *\n *  const graph = {\n *    cart: { metadata }\n *  };\n *\n * @ignore\n */\nexport function nameToState(states: StateClassInternal[]): PlainObjectOf<StateClassInternal> {\n  return states.reduce<PlainObjectOf<StateClassInternal>>(\n    (result: PlainObjectOf<StateClassInternal>, stateClass: StateClassInternal) => {\n      const meta = stateClass[META_KEY]!;\n      result[meta.name!] = stateClass;\n      return result;\n    },\n    {}\n  );\n}\n\n/**\n * Given a object relationship graph will return the full path\n * for the child items. Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const r = {\n *    cart: 'cart',\n *    saved: 'cart.saved',\n *    items: 'cart.saved.items'\n *  };\n *\n * @ignore\n */\nexport function findFullParentPath(\n  obj: StateKeyGraph,\n  newObj: PlainObjectOf<string> = {}\n): PlainObjectOf<string> {\n  const visit = (child: StateKeyGraph, keyToFind: string): string | null => {\n    for (const key in child) {\n      if (child.hasOwnProperty(key) && child[key].indexOf(keyToFind) >= 0) {\n        const parent = visit(child, key);\n        return parent !== null ? `${parent}.${key}` : key;\n      }\n    }\n    return null;\n  };\n\n  for (const key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      const parent = visit(obj, key);\n      newObj[key] = parent ? `${parent}.${key}` : key;\n    }\n  }\n\n  return newObj;\n}\n\n/**\n * Given a object graph, it will return the items topologically sorted Example:\n *\n *  const graph = {\n *    cart: ['saved'],\n *    saved: ['items'],\n *    items: []\n *  };\n *\n * would return:\n *\n *  const results = [\n *    'items',\n *    'saved',\n *    'cart'\n *  ];\n *\n * @ignore\n */\nexport function topologicalSort(graph: StateKeyGraph): string[] {\n  const sorted: string[] = [];\n  const visited: PlainObjectOf<boolean> = {};\n\n  const visit = (name: string, ancestors: string[] = []) => {\n    if (!Array.isArray(ancestors)) {\n      ancestors = [];\n    }\n\n    ancestors.push(name);\n    visited[name] = true;\n\n    graph[name].forEach((dep: string) => {\n      if (ancestors.indexOf(dep) >= 0) {\n        throw new Error(\n          `Circular dependency '${dep}' is required by '${name}': ${ancestors.join(' -> ')}`\n        );\n      }\n\n      if (visited[dep]) {\n        return;\n      }\n\n      visit(dep, ancestors.slice(0));\n    });\n\n    if (sorted.indexOf(name) < 0) {\n      sorted.push(name);\n    }\n  };\n\n  Object.keys(graph).forEach(k => visit(k));\n\n  return sorted.reverse();\n}\n\n/**\n * Returns if the parameter is a object or not.\n *\n * @ignore\n */\nexport function isObject(obj: any) {\n  return (typeof obj === 'object' && obj !== null) || typeof obj === 'function';\n}\n\nexport function getStateDiffChanges<T>(\n  mappedStore: MappedStore,\n  diff: RootStateDiff<T>\n): NgxsSimpleChange {\n  const previousValue: T = getValue(diff.currentAppState, mappedStore.path);\n  const currentValue: T = getValue(diff.newAppState, mappedStore.path);\n  return new NgxsSimpleChange(previousValue, currentValue, !mappedStore.isInitialised);\n}\n","import { OperatorFunction, Observable } from 'rxjs';\nimport { map, filter } from 'rxjs/operators';\nimport { getActionTypeFromInstance } from '../utils/utils';\nimport { ActionContext, ActionStatus } from '../actions-stream';\n\nexport interface ActionCompletion<T = any, E = Error> {\n  action: T;\n  result: {\n    successful: boolean;\n    canceled: boolean;\n    error?: E;\n  };\n}\n\nexport function ofAction<T>(allowedType: any): OperatorFunction<ActionContext, T>;\nexport function ofAction<T>(...allowedTypes: any[]): OperatorFunction<ActionContext, T>;\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will grab actions that have just been dispatched as well as actions that have completed\n */\nexport function ofAction(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been dispatched\n */\nexport function ofActionDispatched(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Dispatched]);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been successfully completed\n */\nexport function ofActionSuccessful(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Successful]);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been canceled\n */\nexport function ofActionCanceled(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Canceled]);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just been completed\n */\nexport function ofActionCompleted(...allowedTypes: any[]) {\n  const allowedStatuses = [\n    ActionStatus.Successful,\n    ActionStatus.Canceled,\n    ActionStatus.Errored\n  ];\n  return ofActionOperator(allowedTypes, allowedStatuses, mapActionResult);\n}\n\n/**\n * RxJS operator for selecting out specific actions.\n *\n * This will ONLY grab actions that have just thrown an error\n */\nexport function ofActionErrored(...allowedTypes: any[]) {\n  return ofActionOperator(allowedTypes, [ActionStatus.Errored]);\n}\n\nfunction ofActionOperator<T = any>(\n  allowedTypes: any[],\n  statuses?: ActionStatus[],\n  mapOperator: () => OperatorFunction<ActionContext, T> = mapAction\n) {\n  const allowedMap = createAllowedActionTypesMap(allowedTypes);\n  const allowedStatusMap = statuses && createAllowedStatusesMap(statuses);\n  return function(o: Observable<ActionContext>) {\n    return o.pipe(\n      filterStatus(allowedMap, allowedStatusMap),\n      mapOperator()\n    );\n  };\n}\n\nfunction filterStatus(allowedTypes: FilterMap, allowedStatuses?: FilterMap) {\n  return filter((ctx: ActionContext) => {\n    const actionType = getActionTypeFromInstance(ctx.action)!;\n    const typeMatch = allowedTypes[actionType];\n    const statusMatch = allowedStatuses ? allowedStatuses[ctx.status] : true;\n    return typeMatch && statusMatch;\n  });\n}\n\nfunction mapActionResult(): OperatorFunction<ActionContext, ActionCompletion> {\n  return map(({ action, status, error }: ActionContext) => {\n    return <ActionCompletion>{\n      action,\n      result: {\n        successful: ActionStatus.Successful === status,\n        canceled: ActionStatus.Canceled === status,\n        error\n      }\n    };\n  });\n}\n\nfunction mapAction<T = any>(): OperatorFunction<ActionContext, T> {\n  return map((ctx: ActionContext) => <T>ctx.action);\n}\n\ninterface FilterMap {\n  [key: string]: boolean;\n}\n\nfunction createAllowedActionTypesMap(types: any[]): FilterMap {\n  return types.reduce(\n    (filterMap: FilterMap, klass: any) => {\n      filterMap[getActionTypeFromInstance(klass)!] = true;\n      return filterMap;\n    },\n    <FilterMap>{}\n  );\n}\n\nfunction createAllowedStatusesMap(statuses: ActionStatus[]): FilterMap {\n  return statuses.reduce(\n    (filterMap: FilterMap, status: ActionStatus) => {\n      filterMap[status] = true;\n      return filterMap;\n    },\n    <FilterMap>{}\n  );\n}\n","import { MonoTypeOperatorFunction, Observable, Observer } from 'rxjs';\nimport { NgxsExecutionStrategy } from '../execution/symbols';\n\n/**\n * Returns operator that will run\n * `subscribe` outside of the ngxs execution context\n */\nexport function leaveNgxs<T>(\n  ngxsExecutionStrategy: NgxsExecutionStrategy\n): MonoTypeOperatorFunction<T> {\n  return (source: Observable<T>) => {\n    return new Observable((sink: Observer<T>) => {\n      return source.subscribe({\n        next(value) {\n          ngxsExecutionStrategy.leave(() => sink.next(value));\n        },\n        error(error) {\n          ngxsExecutionStrategy.leave(() => sink.error(error));\n        },\n        complete() {\n          ngxsExecutionStrategy.leave(() => sink.complete());\n        }\n      });\n    });\n  };\n}\n","import { Injectable, Inject } from '@angular/core';\n\nimport { NgxsExecutionStrategy, NGXS_EXECUTION_STRATEGY } from './symbols';\n\n@Injectable()\nexport class InternalNgxsExecutionStrategy implements NgxsExecutionStrategy {\n  constructor(\n    @Inject(NGXS_EXECUTION_STRATEGY) private _executionStrategy: NgxsExecutionStrategy\n  ) {}\n\n  enter<T>(func: () => T): T {\n    return this._executionStrategy.enter(func);\n  }\n\n  leave<T>(func: () => T): T {\n    return this._executionStrategy.leave(func);\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Subject, Observable } from 'rxjs';\n\nimport { leaveNgxs } from './operators/leave-ngxs';\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\n\n/**\n * Status of a dispatched action\n */\nexport const enum ActionStatus {\n  Dispatched = 'DISPATCHED',\n  Successful = 'SUCCESSFUL',\n  Canceled = 'CANCELED',\n  Errored = 'ERRORED'\n}\n\nexport interface ActionContext<T = any> {\n  status: ActionStatus;\n  action: T;\n  error?: Error;\n}\n\n/**\n * Custom Subject that ensures that subscribers are notified of values in the order that they arrived.\n * A standard Subject does not have this guarantee.\n * For example, given the following code:\n * ```typescript\n *   const subject = new Subject<string>();\n     subject.subscribe(value => {\n       if (value === 'start') subject.next('end');\n     });\n     subject.subscribe(value => { });\n     subject.next('start');\n * ```\n * When `subject` is a standard `Subject<T>` the second subscriber would recieve `end` and then `start`.\n * When `subject` is a `OrderedSubject<T>` the second subscriber would recieve `start` and then `end`.\n */\nexport class OrderedSubject<T> extends Subject<T> {\n  private _itemQueue: T[] = [];\n  private _busyPushingNext = false;\n\n  next(value?: T): void {\n    if (this._busyPushingNext) {\n      this._itemQueue.unshift(value!);\n      return;\n    }\n    this._busyPushingNext = true;\n    super.next(value);\n    while (this._itemQueue.length > 0) {\n      const nextValue = this._itemQueue.pop();\n      super.next(nextValue);\n    }\n    this._busyPushingNext = false;\n  }\n}\n\n/**\n * Internal Action stream that is emitted anytime an action is dispatched.\n */\n@Injectable()\nexport class InternalActions extends OrderedSubject<ActionContext> {}\n\n/**\n * Action stream that is emitted anytime an action is dispatched.\n *\n * You can listen to this in services to react without stores.\n */\n@Injectable()\nexport class Actions extends Observable<any> {\n  // This has to be `Observable<ActionContext>` in the v4. Because `InternalActions`\n  // is a `Subject<ActionContext>`. Leave it as `any` to avoid breaking changes\n  constructor(\n    internalActions$: InternalActions,\n    internalExecutionStrategy: InternalNgxsExecutionStrategy\n  ) {\n    super(observer => {\n      const childSubscription = internalActions$\n        .pipe(leaveNgxs(internalExecutionStrategy))\n        .subscribe({\n          next: ctx => observer.next(ctx),\n          error: error => observer.error(error),\n          complete: () => observer.complete()\n        });\n\n      observer.add(childSubscription);\n    });\n  }\n}\n","export type StateFn = (...args: any[]) => any;\n\n/**\n * Composes a array of functions from left to right. Example:\n *\n *      compose([fn, final])(state, action);\n *\n * then the funcs have a signature like:\n *\n *      function fn (state, action, next) {\n *          console.log('here', state, action, next);\n *          return next(state, action);\n *      }\n *\n *      function final (state, action) {\n *          console.log('here', state, action);\n *          return state;\n *      }\n *\n * the last function should not call `next`.\n *\n * @ignore\n */\nexport const compose = (funcs: StateFn[]) => (...args: any[]) => {\n  const curr = funcs.shift()!;\n  return curr(...args, (...nextArgs: any[]) => compose(funcs)(...nextArgs));\n};\n","import { Injectable } from '@angular/core';\nimport { BehaviorSubject } from 'rxjs';\n\nimport { PlainObject } from '@ngxs/store/internals';\n\n/**\n * BehaviorSubject of the entire state.\n * @ignore\n */\n@Injectable()\nexport class StateStream extends BehaviorSubject<PlainObject> {\n  constructor() {\n    super({});\n  }\n}\n","import { Inject, Injectable, Optional, SkipSelf } from '@angular/core';\nimport { NGXS_PLUGINS, NgxsPlugin, NgxsPluginFn } from './symbols';\n\n@Injectable()\nexport class PluginManager {\n  public plugins: NgxsPluginFn[] = [];\n\n  constructor(\n    @Optional()\n    @SkipSelf()\n    private _parentManager: PluginManager,\n    @Inject(NGXS_PLUGINS)\n    @Optional()\n    private _pluginHandlers: NgxsPlugin[]\n  ) {\n    this.registerHandlers();\n  }\n\n  private get rootPlugins(): NgxsPluginFn[] {\n    return (this._parentManager && this._parentManager.plugins) || this.plugins;\n  }\n\n  private registerHandlers(): void {\n    const pluginHandlers: NgxsPluginFn[] = this.getPluginHandlers();\n    this.rootPlugins.push(...pluginHandlers);\n  }\n\n  private getPluginHandlers(): NgxsPluginFn[] {\n    const handlers: NgxsPlugin[] = this._pluginHandlers || [];\n    return handlers.map(\n      (plugin: NgxsPlugin) =>\n        (plugin.handle ? plugin.handle.bind(plugin) : plugin) as NgxsPluginFn\n    );\n  }\n}\n","import { ErrorHandler, Injectable } from '@angular/core';\nimport { EMPTY, forkJoin, Observable, of, Subject, throwError } from 'rxjs';\nimport { exhaustMap, filter, shareReplay, take } from 'rxjs/operators';\n\nimport { compose } from '../utils/compose';\nimport { ActionContext, ActionStatus, InternalActions } from '../actions-stream';\nimport { StateStream } from './state-stream';\nimport { PluginManager } from '../plugin-manager';\nimport { InternalNgxsExecutionStrategy } from '../execution/internal-ngxs-execution-strategy';\nimport { leaveNgxs } from '../operators/leave-ngxs';\n\n/**\n * Internal Action result stream that is emitted when an action is completed.\n * This is used as a method of returning the action result to the dispatcher\n * for the observable returned by the dispatch(...) call.\n * The dispatcher then asynchronously pushes the result from this stream onto the main action stream as a result.\n */\n@Injectable()\nexport class InternalDispatchedActionResults extends Subject<ActionContext> {}\n\n@Injectable()\nexport class InternalDispatcher {\n  constructor(\n    private _errorHandler: ErrorHandler,\n    private _actions: InternalActions,\n    private _actionResults: InternalDispatchedActionResults,\n    private _pluginManager: PluginManager,\n    private _stateStream: StateStream,\n    private _ngxsExecutionStrategy: InternalNgxsExecutionStrategy\n  ) {}\n\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(actionOrActions: any | any[]): Observable<any> {\n    const result = this._ngxsExecutionStrategy.enter(() =>\n      this.dispatchByEvents(actionOrActions)\n    );\n\n    result.subscribe({\n      error: error =>\n        this._ngxsExecutionStrategy.leave(() => {\n          try {\n            this._errorHandler.handleError(error);\n          } catch {}\n        })\n    });\n\n    return result.pipe(leaveNgxs(this._ngxsExecutionStrategy));\n  }\n\n  private dispatchByEvents(actionOrActions: any | any[]): Observable<any> {\n    if (Array.isArray(actionOrActions)) {\n      if (actionOrActions.length === 0) return of(this._stateStream.getValue());\n      return forkJoin(actionOrActions.map(action => this.dispatchSingle(action)));\n    } else {\n      return this.dispatchSingle(actionOrActions);\n    }\n  }\n\n  private dispatchSingle(action: any): Observable<any> {\n    const prevState = this._stateStream.getValue();\n    const plugins = this._pluginManager.plugins;\n\n    return (compose([\n      ...plugins,\n      (nextState: any, nextAction: any) => {\n        if (nextState !== prevState) {\n          this._stateStream.next(nextState);\n        }\n        const actionResult$ = this.getActionResultStream(nextAction);\n        actionResult$.subscribe(ctx => this._actions.next(ctx));\n        this._actions.next({ action: nextAction, status: ActionStatus.Dispatched });\n        return this.createDispatchObservable(actionResult$);\n      }\n    ])(prevState, action) as Observable<any>).pipe(shareReplay());\n  }\n\n  private getActionResultStream(action: any): Observable<ActionContext> {\n    return this._actionResults.pipe(\n      filter(\n        (ctx: ActionContext) => ctx.action === action && ctx.status !== ActionStatus.Dispatched\n      ),\n      take(1),\n      shareReplay()\n    );\n  }\n\n  private createDispatchObservable(actionResult$: Observable<ActionContext>): Observable<any> {\n    return actionResult$\n      .pipe(\n        exhaustMap((ctx: ActionContext) => {\n          switch (ctx.status) {\n            case ActionStatus.Successful:\n              return of(this._stateStream.getValue());\n            case ActionStatus.Errored:\n              return throwError(ctx.error);\n            default:\n              return EMPTY;\n          }\n        })\n      )\n      .pipe(shareReplay());\n  }\n}\n","/**\n * Object freeze code\n * https://github.com/jsdf/deep-freeze\n */\nexport const deepFreeze = (o: any) => {\n  Object.freeze(o);\n\n  const oIsFunction = typeof o === 'function';\n  const hasOwnProp = Object.prototype.hasOwnProperty;\n\n  Object.getOwnPropertyNames(o).forEach(function(prop) {\n    if (\n      hasOwnProp.call(o, prop) &&\n      (oIsFunction ? prop !== 'caller' && prop !== 'callee' && prop !== 'arguments' : true) &&\n      o[prop] !== null &&\n      (typeof o[prop] === 'object' || typeof o[prop] === 'function') &&\n      !Object.isFrozen(o[prop])\n    ) {\n      deepFreeze(o[prop]);\n    }\n  });\n\n  return o;\n};\n","import { Inject, Injectable } from '@angular/core';\nimport { NG_DEV_MODE, NG_TEST_MODE } from '../symbols';\nimport { Callback } from '../internal/internals';\n\n@Injectable()\nexport class HostEnvironment {\n  constructor(\n    @Inject(NG_DEV_MODE) public isDevMode: Callback<boolean>,\n    @Inject(NG_TEST_MODE) public isTestMode: Callback<boolean>\n  ) {}\n}\n","import { Injectable } from '@angular/core';\n\nimport {\n  CONFIG_MESSAGES as MESSAGES,\n  VALIDATION_CODE as CODE\n} from '../configs/messages.config';\nimport { NgxsConfig } from '../symbols';\nimport { HostEnvironment } from '../host-environment/host-environment';\n\n@Injectable()\nexport class ConfigValidator {\n  constructor(private _host: HostEnvironment, private _config: NgxsConfig) {}\n\n  private get isIncorrectProduction(): boolean {\n    return !this._host.isDevMode() && this._config.developmentMode;\n  }\n\n  private get isIncorrectDevelopment(): boolean {\n    return this._host.isDevMode() && !this._config.developmentMode;\n  }\n\n  public verifyDevMode(): void {\n    if (this._host.isTestMode()) {\n      return;\n    }\n\n    if (this.isIncorrectProduction) {\n      console.warn(MESSAGES[CODE.INCORRECT_PRODUCTION]());\n    } else if (this.isIncorrectDevelopment) {\n      console.warn(MESSAGES[CODE.INCORRECT_DEVELOPMENT]());\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\n\nimport { StateOperations, StatesAndDefaults } from '../internal/internals';\nimport { InternalDispatcher } from '../internal/dispatcher';\nimport { StateStream } from './state-stream';\nimport { NgxsConfig } from '../symbols';\nimport { deepFreeze } from '../utils/freeze';\nimport { ConfigValidator } from '../internal/config-validator';\n\n/**\n * State Context factory class\n * @ignore\n */\n@Injectable()\nexport class InternalStateOperations {\n  constructor(\n    private _stateStream: StateStream,\n    private _dispatcher: InternalDispatcher,\n    private _config: NgxsConfig,\n    configValidator: ConfigValidator\n  ) {\n    configValidator.verifyDevMode();\n  }\n\n  /**\n   * Returns the root state operators.\n   */\n  getRootStateOperations(): StateOperations<any> {\n    const rootStateOperations = {\n      getState: () => this._stateStream.getValue(),\n      setState: (newState: any) => this._stateStream.next(newState),\n      dispatch: (actions: any[]) => this._dispatcher.dispatch(actions)\n    };\n\n    if (this._config.developmentMode) {\n      return this.ensureStateAndActionsAreImmutable(rootStateOperations);\n    }\n\n    return rootStateOperations;\n  }\n\n  private ensureStateAndActionsAreImmutable(root: StateOperations<any>): StateOperations<any> {\n    return {\n      getState: () => root.getState(),\n      setState: value => {\n        const frozenValue = deepFreeze(value);\n        return root.setState(frozenValue);\n      },\n      dispatch: actions => {\n        return root.dispatch(actions);\n      }\n    };\n  }\n\n  setStateToTheCurrentWithNew(results: StatesAndDefaults): void {\n    const stateOperations: StateOperations<any> = this.getRootStateOperations();\n\n    // Get our current stream\n    const currentState = stateOperations.getState();\n    // Set the state to the current + new\n    stateOperations.setState({ ...currentState, ...results.defaults });\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Observable } from 'rxjs';\n\nimport { NgxsLifeCycle, NgxsSimpleChange, StateContext, StateOperator } from '../symbols';\nimport { getStateDiffChanges, MappedStore } from '../internal/internals';\nimport { setValue, getValue } from '../utils/utils';\nimport { InternalStateOperations } from '../internal/state-operations';\nimport { simplePatch } from './state-operators';\n\n/**\n * State Context factory class\n * @ignore\n */\n@Injectable()\nexport class StateContextFactory {\n  constructor(private _internalStateOperations: InternalStateOperations) {}\n\n  /**\n   * Create the state context\n   */\n  createStateContext<T>(mappedStore: MappedStore): StateContext<T> {\n    const root = this._internalStateOperations.getRootStateOperations();\n\n    function getState(currentAppState: any): T {\n      return getValue(currentAppState, mappedStore.path);\n    }\n\n    function setStateValue(currentAppState: any, newValue: T): any {\n      const newAppState = setValue(currentAppState, mappedStore.path, newValue);\n      const instance: NgxsLifeCycle = mappedStore.instance;\n\n      if (instance.ngxsOnChanges) {\n        const change: NgxsSimpleChange = getStateDiffChanges<T>(mappedStore, {\n          currentAppState,\n          newAppState\n        });\n\n        instance.ngxsOnChanges(change);\n      }\n\n      root.setState(newAppState);\n      return newAppState;\n      // In doing this refactoring I noticed that there is a 'bug' where the\n      // application state is returned instead of this state slice.\n      // This has worked this way since the beginning see:\n      // https://github.com/ngxs/store/blame/324c667b4b7debd8eb979006c67ca0ae347d88cd/src/state-factory.ts\n      // This needs to be fixed, but is a 'breaking' change.\n      // I will do this fix in a subsequent PR and we can decide how to handle it.\n    }\n\n    function setStateFromOperator(currentAppState: any, stateOperator: StateOperator<T>) {\n      const local = getState(currentAppState);\n      const newValue = stateOperator(local);\n      return setStateValue(currentAppState, newValue);\n    }\n\n    function isStateOperator(value: T | StateOperator<T>): value is StateOperator<T> {\n      return typeof value === 'function';\n    }\n\n    return {\n      getState(): T {\n        const currentAppState = root.getState();\n        return getState(currentAppState);\n      },\n      patchState(val: Partial<T>): T {\n        const currentAppState = root.getState();\n        const patchOperator = simplePatch<T>(val);\n        return setStateFromOperator(currentAppState, patchOperator);\n      },\n      setState(val: T | StateOperator<T>): T {\n        const currentAppState = root.getState();\n        return isStateOperator(val)\n          ? setStateFromOperator(currentAppState, val)\n          : setStateValue(currentAppState, val);\n      },\n      dispatch(actions: any | any[]): Observable<void> {\n        return root.dispatch(actions);\n      }\n    };\n  }\n}\n","import {\n  CONFIG_MESSAGES as MESSAGES,\n  VALIDATION_CODE as CODE\n} from '../configs/messages.config';\nimport { StateOperator } from '../symbols';\n\nexport function simplePatch<T>(val: Partial<T>): StateOperator<T> {\n  return (existingState: Readonly<T>) => {\n    if (Array.isArray(val)) {\n      throw new Error(MESSAGES[CODE.PATCHING_ARRAY]());\n    } else if (typeof val !== 'object') {\n      throw new Error(MESSAGES[CODE.PATCHING_PRIMITIVE]());\n    }\n\n    const newState: any = { ...(existingState as any) };\n    for (const key in val) {\n      // deep clone for patch compatibility\n      // noinspection JSUnfilteredForInLoop (IDE)\n      newState[key] = (val as any)[key];\n    }\n\n    return newState as T;\n  };\n}\n","import {\n  getStoreMetadata,\n  MetaDataModel,\n  StateClassInternal,\n  StatesByName\n} from '../internal/internals';\nimport {\n  CONFIG_MESSAGES as MESSAGES,\n  VALIDATION_CODE as CODE\n} from '../configs/messages.config';\n\nexport abstract class StoreValidators {\n  public static stateNameRegex: RegExp = new RegExp('^[a-zA-Z0-9_]+$');\n\n  public static stateNameErrorMessage(name: string) {\n    return MESSAGES[CODE.STATE_NAME](name);\n  }\n\n  public static checkCorrectStateName(name: string | null) {\n    if (!name) {\n      throw new Error(MESSAGES[CODE.STATE_NAME_PROPERTY]());\n    }\n\n    if (!this.stateNameRegex.test(name)) {\n      throw new Error(this.stateNameErrorMessage(name));\n    }\n  }\n\n  public static checkStateNameIsUnique(\n    state: StateClassInternal,\n    statesByName: StatesByName\n  ): string {\n    const meta: MetaDataModel = this.getValidStateMeta(state);\n    const stateName: string = meta!.name as string;\n    const existingState = statesByName[stateName];\n    if (existingState && existingState !== state) {\n      throw new Error(MESSAGES[CODE.STATE_UNIQUE](stateName, state.name, existingState.name));\n    }\n    return stateName;\n  }\n\n  public static getValidStateMeta(state: StateClassInternal): MetaDataModel {\n    const meta: MetaDataModel = getStoreMetadata(state);\n    if (!meta) {\n      throw new Error(MESSAGES[CODE.STATE_DECORATOR]());\n    }\n\n    return meta;\n  }\n}\n","import { Injectable, Injector, Optional, SkipSelf, Inject } from '@angular/core';\nimport { forkJoin, from, Observable, of, throwError } from 'rxjs';\nimport {\n  catchError,\n  defaultIfEmpty,\n  filter,\n  map,\n  mergeMap,\n  shareReplay,\n  takeUntil\n} from 'rxjs/operators';\n\nimport { META_KEY, NgxsConfig } from '../symbols';\nimport {\n  buildGraph,\n  findFullParentPath,\n  isObject,\n  MappedStore,\n  MetaDataModel,\n  nameToState,\n  propGetter,\n  StateClassInternal,\n  StateKeyGraph,\n  StatesAndDefaults,\n  StatesByName,\n  topologicalSort,\n  RuntimeSelectorContext,\n  SharedSelectorOptions\n} from './internals';\nimport { getActionTypeFromInstance, getValue, setValue } from '../utils/utils';\nimport { ofActionDispatched } from '../operators/of-action';\nimport { ActionContext, ActionStatus, InternalActions } from '../actions-stream';\nimport { InternalDispatchedActionResults } from '../internal/dispatcher';\nimport { StateContextFactory } from '../internal/state-context-factory';\nimport { StoreValidators } from '../utils/store-validators';\nimport { INITIAL_STATE_TOKEN, PlainObjectOf, memoize } from '@ngxs/store/internals';\n\n/**\n * State factory class\n * @ignore\n */\n@Injectable()\nexport class StateFactory {\n  private _connected = false;\n\n  constructor(\n    private _injector: Injector,\n    private _config: NgxsConfig,\n    @Optional()\n    @SkipSelf()\n    private _parentFactory: StateFactory,\n    private _actions: InternalActions,\n    private _actionResults: InternalDispatchedActionResults,\n    private _stateContextFactory: StateContextFactory,\n    @Optional()\n    @Inject(INITIAL_STATE_TOKEN)\n    private _initialState: any\n  ) {}\n\n  private _states: MappedStore[] = [];\n\n  public get states(): MappedStore[] {\n    return this._parentFactory ? this._parentFactory.states : this._states;\n  }\n\n  private _statesByName: StatesByName = {};\n\n  public get statesByName(): StatesByName {\n    return this._parentFactory ? this._parentFactory.statesByName : this._statesByName;\n  }\n\n  private _statePaths: PlainObjectOf<string> = {};\n\n  private get statePaths(): PlainObjectOf<string> {\n    return this._parentFactory ? this._parentFactory.statePaths : this._statePaths;\n  }\n\n  public getRuntimeSelectorContext = memoize(() => {\n    const stateFactory = this;\n    const context: RuntimeSelectorContext = this._parentFactory\n      ? this._parentFactory.getRuntimeSelectorContext()\n      : {\n          getStateGetter(key: string) {\n            const path = stateFactory.statePaths[key];\n            return path ? propGetter(path.split('.'), stateFactory._config) : () => undefined;\n          },\n          getSelectorOptions(localOptions?: SharedSelectorOptions) {\n            const globalSelectorOptions = stateFactory._config.selectorOptions;\n            return {\n              ...globalSelectorOptions,\n              ...(localOptions || {})\n            };\n          }\n        };\n    return context;\n  });\n\n  private static cloneDefaults(defaults: any): any {\n    let value = {};\n\n    if (Array.isArray(defaults)) {\n      value = defaults.slice();\n    } else if (isObject(defaults)) {\n      value = { ...defaults };\n    } else if (defaults === undefined) {\n      value = {};\n    } else {\n      value = defaults;\n    }\n\n    return value;\n  }\n\n  private static checkStatesAreValid(stateClasses: StateClassInternal[]): void {\n    stateClasses.forEach(StoreValidators.getValidStateMeta);\n  }\n\n  /**\n   * Add a new state to the global defs.\n   */\n  add(stateClasses: StateClassInternal[]): MappedStore[] {\n    StateFactory.checkStatesAreValid(stateClasses);\n    const { newStates } = this.addToStatesMap(stateClasses);\n    if (!newStates.length) return [];\n\n    const stateGraph: StateKeyGraph = buildGraph(newStates);\n    const sortedStates: string[] = topologicalSort(stateGraph);\n    const paths: PlainObjectOf<string> = findFullParentPath(stateGraph);\n    const nameGraph: PlainObjectOf<StateClassInternal> = nameToState(newStates);\n    const bootstrappedStores: MappedStore[] = [];\n\n    for (const name of sortedStates) {\n      const stateClass: StateClassInternal = nameGraph[name];\n      const path: string = paths[name];\n      const meta: MetaDataModel = stateClass[META_KEY]!;\n\n      this.addRuntimeInfoToMeta(meta, path);\n\n      const stateMap: MappedStore = {\n        name,\n        path,\n        isInitialised: false,\n        actions: meta.actions,\n        instance: this._injector.get(stateClass),\n        defaults: StateFactory.cloneDefaults(meta.defaults)\n      };\n\n      // ensure our store hasn't already been added\n      // but don't throw since it could be lazy\n      // loaded from different paths\n      if (!this.hasBeenMountedAndBootstrapped(name, path)) {\n        bootstrappedStores.push(stateMap);\n      }\n\n      this.states.push(stateMap);\n    }\n\n    return bootstrappedStores;\n  }\n\n  /**\n   * Add a set of states to the store and return the defaults\n   */\n  addAndReturnDefaults(stateClasses: StateClassInternal[]): StatesAndDefaults {\n    const classes: StateClassInternal[] = stateClasses || [];\n\n    const mappedStores: MappedStore[] = this.add(classes);\n    const defaults = mappedStores.reduce(\n      (result: any, mappedStore: MappedStore) =>\n        setValue(result, mappedStore.path, mappedStore.defaults),\n      {}\n    );\n    return { defaults, states: mappedStores };\n  }\n\n  /**\n   * Bind the actions to the handlers\n   */\n  connectActionHandlers() {\n    if (this._connected) return;\n    this._actions\n      .pipe(\n        filter((ctx: ActionContext) => ctx.status === ActionStatus.Dispatched),\n        mergeMap(({ action }) =>\n          this.invokeActions(this._actions, action!).pipe(\n            map(() => <ActionContext>{ action, status: ActionStatus.Successful }),\n            defaultIfEmpty(<ActionContext>{ action, status: ActionStatus.Canceled }),\n            catchError(error =>\n              of(<ActionContext>{ action, status: ActionStatus.Errored, error })\n            )\n          )\n        )\n      )\n      .subscribe(ctx => this._actionResults.next(ctx));\n    this._connected = true;\n  }\n\n  /**\n   * Invoke actions on the states.\n   */\n  invokeActions(actions$: InternalActions, action: any) {\n    const results = [];\n\n    for (const metadata of this.states) {\n      const type = getActionTypeFromInstance(action)!;\n      const actionMetas = metadata.actions[type];\n\n      if (actionMetas) {\n        for (const actionMeta of actionMetas) {\n          const stateContext = this._stateContextFactory.createStateContext(metadata);\n          try {\n            let result = metadata.instance[actionMeta.fn](stateContext, action);\n\n            if (result instanceof Promise) {\n              result = from(result);\n            }\n\n            if (result instanceof Observable) {\n              if (actionMeta.options.cancelUncompleted) {\n                // todo: ofActionDispatched should be used with action class\n                result = result.pipe(\n                  takeUntil(actions$.pipe(ofActionDispatched(action as any)))\n                );\n              }\n            } else {\n              result = of({}).pipe(shareReplay());\n            }\n\n            results.push(result);\n          } catch (e) {\n            results.push(throwError(e));\n          }\n        }\n      }\n    }\n\n    if (!results.length) {\n      results.push(of({}));\n    }\n\n    return forkJoin(results);\n  }\n\n  private addToStatesMap(\n    stateClasses: StateClassInternal[]\n  ): { newStates: StateClassInternal[] } {\n    const newStates: StateClassInternal[] = [];\n    const statesMap: StatesByName = this.statesByName;\n\n    for (const stateClass of stateClasses) {\n      const stateName: string = StoreValidators.checkStateNameIsUnique(stateClass, statesMap);\n      const unmountedState = !statesMap[stateName];\n      if (unmountedState) {\n        newStates.push(stateClass);\n        statesMap[stateName] = stateClass;\n      }\n    }\n\n    return { newStates };\n  }\n\n  private addRuntimeInfoToMeta(meta: MetaDataModel, path: string): void {\n    this.statePaths[meta.name!] = path;\n    // TODO: v4 - we plan to get rid of the path property because it is non-deterministic\n    // we can do this when we get rid of the incorrectly exposed getStoreMetadata\n    // We will need to come up with an alternative in v4 because this is used by many plugins\n    meta.path = path;\n  }\n\n  /**\n   * @description\n   * the method checks if the state has already been added to the tree\n   * and completed the life cycle\n   * @param name\n   * @param path\n   */\n  private hasBeenMountedAndBootstrapped(name: string, path: string): boolean {\n    const valueIsBootstrappedInInitialState: boolean =\n      getValue(this._initialState, path) !== undefined;\n    return this.statesByName[name] && valueIsBootstrappedInInitialState;\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { NgxsBootstrapper, PlainObject } from '@ngxs/store/internals';\nimport { filter, mergeMap, tap } from 'rxjs/operators';\n\nimport { StateContextFactory } from './state-context-factory';\nimport { InternalStateOperations } from './state-operations';\nimport { getStateDiffChanges, MappedStore, StatesAndDefaults } from './internals';\nimport { NgxsLifeCycle, NgxsSimpleChange, StateContext } from '../symbols';\n\n@Injectable()\nexport class LifecycleStateManager {\n  constructor(\n    private internalStateOperations: InternalStateOperations,\n    private stateContextFactory: StateContextFactory,\n    private bootstrapper: NgxsBootstrapper\n  ) {}\n\n  ngxsBootstrap<T>(action: T, results: StatesAndDefaults | undefined): void {\n    this.internalStateOperations\n      .getRootStateOperations()\n      .dispatch(action)\n      .pipe(\n        filter(() => !!results),\n        tap(() => this.invokeInit(results!.states)),\n        mergeMap(() => this.bootstrapper.appBootstrapped$),\n        filter(appBootstrapped => !!appBootstrapped)\n      )\n      .subscribe(() => this.invokeBootstrap(results!.states));\n  }\n\n  /**\n   * Invoke the init function on the states.\n   */\n  invokeInit(mappedStores: MappedStore[]): void {\n    for (const mappedStore of mappedStores) {\n      const instance: NgxsLifeCycle = mappedStore.instance;\n\n      if (instance.ngxsOnChanges) {\n        const currentAppState: PlainObject = {};\n        const newAppState: PlainObject = this.internalStateOperations\n          .getRootStateOperations()\n          .getState();\n\n        const firstDiffChange: NgxsSimpleChange = getStateDiffChanges(mappedStore, {\n          currentAppState,\n          newAppState\n        });\n\n        instance.ngxsOnChanges(firstDiffChange);\n      }\n\n      if (instance.ngxsOnInit) {\n        instance.ngxsOnInit(this.getStateContext(mappedStore));\n      }\n\n      mappedStore.isInitialised = true;\n    }\n  }\n\n  /**\n   * Invoke the bootstrap function on the states.\n   */\n  invokeBootstrap(mappedStores: MappedStore[]) {\n    for (const mappedStore of mappedStores) {\n      const instance: NgxsLifeCycle = mappedStore.instance;\n      if (instance.ngxsAfterBootstrap) {\n        instance.ngxsAfterBootstrap(this.getStateContext(mappedStore));\n      }\n    }\n  }\n\n  private getStateContext(mappedStore: MappedStore): StateContext<any> {\n    return this.stateContextFactory.createStateContext(mappedStore);\n  }\n}\n","import { memoize } from '@ngxs/store/internals';\n\nimport {\n  ensureSelectorMetadata,\n  getSelectorMetadata,\n  getStoreMetadata,\n  SelectorMetaDataModel,\n  SharedSelectorOptions,\n  RuntimeSelectorContext,\n  SelectorFactory,\n  SelectFromRootState\n} from '../internal/internals';\n\nconst SELECTOR_OPTIONS_META_KEY = 'NGXS_SELECTOR_OPTIONS_META';\n\nexport const selectorOptionsMetaAccessor = {\n  getOptions: (target: any): SharedSelectorOptions => {\n    return (target && (<any>target)[SELECTOR_OPTIONS_META_KEY]) || {};\n  },\n  defineOptions: (target: any, options: SharedSelectorOptions) => {\n    if (!target) return;\n    (<any>target)[SELECTOR_OPTIONS_META_KEY] = options;\n  }\n};\n\ninterface CreationMetadata {\n  containerClass: any;\n  selectorName: string;\n  getSelectorOptions?: () => SharedSelectorOptions;\n}\n\ninterface RuntimeSelectorInfo {\n  selectorOptions: SharedSelectorOptions;\n  argumentSelectorFunctions: SelectFromRootState[];\n}\n\n/**\n * Function for creating a selector\n * @param selectors The selectors to use to create the arguments of this function\n * @param originalFn The original function being made into a selector\n * @param creationMetadata\n */\nexport function createSelector<T extends (...args: any[]) => any>(\n  selectors: any[] | undefined,\n  originalFn: T,\n  creationMetadata?: CreationMetadata\n) {\n  const containerClass = creationMetadata && creationMetadata.containerClass;\n  const wrappedFn = function wrappedSelectorFn(...args: any[]) {\n    const returnValue = originalFn.apply(containerClass, args);\n    if (returnValue instanceof Function) {\n      const innerMemoizedFn = memoize.apply(null, [returnValue]);\n      return innerMemoizedFn;\n    }\n    return returnValue;\n  } as T;\n  const memoizedFn = memoize(wrappedFn);\n  Object.setPrototypeOf(memoizedFn, originalFn);\n\n  const selectorMetaData = setupSelectorMetadata<T>(originalFn, creationMetadata);\n\n  const makeRootSelector: SelectorFactory = (context: RuntimeSelectorContext) => {\n    const { argumentSelectorFunctions, selectorOptions } = getRuntimeSelectorInfo(\n      context,\n      selectorMetaData,\n      selectors\n    );\n\n    return function selectFromRoot(rootState: any) {\n      // Determine arguments from the app state using the selectors\n      const results = argumentSelectorFunctions.map(argFn => argFn(rootState));\n\n      // if the lambda tries to access a something on the\n      // state that doesn't exist, it will throw a TypeError.\n      // since this is quite usual behaviour, we simply return undefined if so.\n      try {\n        return memoizedFn(...results);\n      } catch (ex) {\n        if (ex instanceof TypeError && selectorOptions.suppressErrors) {\n          return undefined;\n        }\n\n        throw ex;\n      }\n    };\n  };\n\n  selectorMetaData.makeRootSelector = makeRootSelector;\n\n  return memoizedFn;\n}\n\nfunction setupSelectorMetadata<T extends (...args: any[]) => any>(\n  originalFn: T,\n  creationMetadata: CreationMetadata | undefined\n) {\n  const selectorMetaData = ensureSelectorMetadata(originalFn);\n  selectorMetaData.originalFn = originalFn;\n  let getExplicitSelectorOptions = () => ({});\n  if (creationMetadata) {\n    selectorMetaData.containerClass = creationMetadata.containerClass;\n    selectorMetaData.selectorName = creationMetadata.selectorName;\n    getExplicitSelectorOptions =\n      creationMetadata.getSelectorOptions || getExplicitSelectorOptions;\n  }\n  const selectorMetaDataClone = { ...selectorMetaData };\n  selectorMetaData.getSelectorOptions = () =>\n    getLocalSelectorOptions(selectorMetaDataClone, getExplicitSelectorOptions());\n  return selectorMetaData;\n}\n\nfunction getRuntimeSelectorInfo(\n  context: RuntimeSelectorContext,\n  selectorMetaData: SelectorMetaDataModel,\n  selectors: any[] | undefined = []\n): RuntimeSelectorInfo {\n  const localSelectorOptions = selectorMetaData.getSelectorOptions();\n  const selectorOptions = context.getSelectorOptions(localSelectorOptions);\n  const selectorsToApply = getSelectorsToApply(\n    selectors,\n    selectorOptions,\n    selectorMetaData.containerClass\n  );\n\n  const argumentSelectorFunctions = selectorsToApply.map(selector => {\n    const factory = getRootSelectorFactory(selector);\n    return factory(context);\n  });\n  return {\n    selectorOptions,\n    argumentSelectorFunctions\n  };\n}\n\nfunction getLocalSelectorOptions(\n  selectorMetaData: SelectorMetaDataModel,\n  explicitOptions: SharedSelectorOptions\n): SharedSelectorOptions {\n  return {\n    ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.containerClass) || {}),\n    ...(selectorOptionsMetaAccessor.getOptions(selectorMetaData.originalFn) || {}),\n    ...(selectorMetaData.getSelectorOptions() || {}),\n    ...explicitOptions\n  };\n}\n\nfunction getSelectorsToApply(\n  selectors: any[] | undefined = [],\n  selectorOptions: SharedSelectorOptions,\n  containerClass: any\n) {\n  const selectorsToApply = [];\n  const canInjectContainerState =\n    selectors.length === 0 || selectorOptions.injectContainerState;\n  if (containerClass && canInjectContainerState) {\n    // If we are on a state class, add it as the first selector parameter\n    const metadata = getStoreMetadata(containerClass);\n    if (metadata) {\n      selectorsToApply.push(containerClass);\n    }\n  }\n  if (selectors) {\n    selectorsToApply.push(...selectors);\n  }\n  return selectorsToApply;\n}\n\n/**\n * This function gets the factory function to create the selector to get the selected slice from the app state\n * @ignore\n */\nexport function getRootSelectorFactory(selector: any): SelectorFactory {\n  const metadata = getSelectorMetadata(selector) || getStoreMetadata(selector);\n  return (metadata && metadata.makeRootSelector) || (() => selector);\n}\n","// tslint:disable:unified-signatures\nimport { Inject, Injectable, Optional, Type } from '@angular/core';\nimport { Observable, of, Subscription, throwError } from 'rxjs';\nimport { catchError, distinctUntilChanged, map, take } from 'rxjs/operators';\nimport { INITIAL_STATE_TOKEN, PlainObject } from '@ngxs/store/internals';\n\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\nimport { InternalStateOperations } from './internal/state-operations';\nimport { getRootSelectorFactory } from './utils/selector-utils';\nimport { StateStream } from './internal/state-stream';\nimport { leaveNgxs } from './operators/leave-ngxs';\nimport { NgxsConfig } from './symbols';\nimport { StateToken } from './state-token/state-token';\nimport { StateFactory } from './internal/state-factory';\n\n@Injectable()\nexport class Store {\n  constructor(\n    private _stateStream: StateStream,\n    private _internalStateOperations: InternalStateOperations,\n    private _config: NgxsConfig,\n    private _internalExecutionStrategy: InternalNgxsExecutionStrategy,\n    private _stateFactory: StateFactory,\n    @Optional()\n    @Inject(INITIAL_STATE_TOKEN)\n    initialStateValue: any\n  ) {\n    this.initStateStream(initialStateValue);\n  }\n\n  /**\n   * Dispatches event(s).\n   */\n  dispatch(event: any | any[]): Observable<any> {\n    return this._internalStateOperations.getRootStateOperations().dispatch(event);\n  }\n\n  /**\n   * Selects a slice of data from the store.\n   */\n  select<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\n  select<T = any>(selector: string | Type<any>): Observable<T>;\n  select<T>(selector: StateToken<T>): Observable<T>;\n  select(selector: any): Observable<any> {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return this._stateStream.pipe(\n      map(selectorFn),\n      catchError((err: Error): Observable<never> | Observable<undefined> => {\n        // if error is TypeError we swallow it to prevent usual errors with property access\n        const { suppressErrors } = this._config.selectorOptions;\n\n        if (err instanceof TypeError && suppressErrors) {\n          return of(undefined);\n        }\n\n        // rethrow other errors\n        return throwError(err);\n      }),\n      distinctUntilChanged(),\n      leaveNgxs(this._internalExecutionStrategy)\n    );\n  }\n\n  /**\n   * Select one slice of data from the store.\n   */\n\n  selectOnce<T>(selector: (state: any, ...states: any[]) => T): Observable<T>;\n  selectOnce<T = any>(selector: string | Type<any>): Observable<T>;\n  selectOnce<T>(selector: StateToken<T>): Observable<T>;\n  selectOnce(selector: any): Observable<any> {\n    return this.select(selector).pipe(take(1));\n  }\n\n  /**\n   * Select a snapshot from the state.\n   */\n  selectSnapshot<T>(selector: (state: any, ...states: any[]) => T): T;\n  selectSnapshot<T = any>(selector: string | Type<any>): T;\n  selectSnapshot<T>(selector: StateToken<T>): T;\n  selectSnapshot(selector: any): any {\n    const selectorFn = this.getStoreBoundSelectorFn(selector);\n    return selectorFn(this._stateStream.getValue());\n  }\n\n  /**\n   * Allow the user to subscribe to the root of the state\n   */\n  subscribe(fn?: (value: any) => void): Subscription {\n    return this._stateStream.pipe(leaveNgxs(this._internalExecutionStrategy)).subscribe(fn);\n  }\n\n  /**\n   * Return the raw value of the state.\n   */\n  snapshot(): any {\n    return this._internalStateOperations.getRootStateOperations().getState();\n  }\n\n  /**\n   * Reset the state to a specific point in time. This method is useful\n   * for plugin's who need to modify the state directly or unit testing.\n   */\n  reset(state: any) {\n    return this._internalStateOperations.getRootStateOperations().setState(state);\n  }\n\n  private getStoreBoundSelectorFn(selector: any) {\n    const makeSelectorFn = getRootSelectorFactory(selector);\n    const runtimeContext = this._stateFactory.getRuntimeSelectorContext();\n    return makeSelectorFn(runtimeContext);\n  }\n\n  private initStateStream(initialStateValue: any): void {\n    const value: PlainObject = this._stateStream.value;\n    const storeIsEmpty: boolean = !value || Object.keys(value).length === 0;\n    if (storeIsEmpty) {\n      const defaultStateNotEmpty: boolean = Object.keys(this._config.defaultsState).length > 0;\n      const storeValues: PlainObject = defaultStateNotEmpty\n        ? { ...this._config.defaultsState, ...initialStateValue }\n        : initialStateValue;\n\n      this._stateStream.next(storeValues);\n    }\n  }\n}\n","import { Injectable } from '@angular/core';\n\nimport { Store } from '../../store';\nimport { NgxsConfig } from '../../symbols';\n\n/**\n * Allows the select decorator to get access to the DI store.\n * @internal only use in @Select decorator\n * @ignore\n */\n@Injectable()\nexport class SelectFactory {\n  public static store: Store | null = null;\n  public static config: NgxsConfig | null = null;\n\n  constructor(store: Store, config: NgxsConfig) {\n    SelectFactory.store = store;\n    SelectFactory.config = config;\n  }\n}\n","import { PlainObject } from '@ngxs/store/internals';\n\n/**\n * Init action\n */\nexport class InitState {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@INIT';\n  }\n}\n\n/**\n * Update action\n */\nexport class UpdateState {\n  static get type() {\n    // NOTE: Not necessary to declare the type in this way in your code. See https://github.com/ngxs/store/pull/644#issuecomment-436003138\n    return '@@UPDATE_STATE';\n  }\n\n  constructor(public addedStates?: PlainObject) {}\n}\n","import { isDevMode } from '@angular/core';\nimport { Observable, ReplaySubject } from 'rxjs';\n\n/**\n * Keep it as a single `const` variable since this `ReplaySubject`\n * will be private and accessible only within this file.\n */\nconst _ivyEnabledInDevMode$ = new ReplaySubject<boolean>(1);\n\n/**\n * Ivy exposes helper functions to the global `window.ng` object.\n * Those functions are `getComponent, getContext,\n * getListeners, getViewComponent, getHostElement, getInjector,\n * getRootComponents, getDirectives, getDebugNode`\n * Previously, old view engine exposed `window.ng.coreTokens` and\n * `window.ng.probe` if an application was in development/production.\n * Ivy doesn't expose these functions in production. Developers will be able\n * to see warnings in both JIT/AOT modes, but only if an application\n * is in development.\n */\nexport function setIvyEnabledInDevMode(): void {\n  try {\n    // `try-catch` will also handle server-side rendering, as\n    // `window is not defined` will not be thrown.\n    const ng = (window as any).ng;\n    const _viewEngineEnabled = !!ng.probe && !!ng.coreTokens;\n    const _ivyEnabledInDevMode = !_viewEngineEnabled && isDevMode();\n    _ivyEnabledInDevMode$.next(_ivyEnabledInDevMode);\n  } catch {\n    _ivyEnabledInDevMode$.next(false);\n  } finally {\n    _ivyEnabledInDevMode$.complete();\n  }\n}\n\nexport function ivyEnabledInDevMode(): Observable<boolean> {\n  return _ivyEnabledInDevMode$.asObservable();\n}\n","import { Inject, NgModule, Optional } from '@angular/core';\n\nimport { StateFactory } from '../internal/state-factory';\nimport { InternalStateOperations } from '../internal/state-operations';\nimport { Store } from '../store';\nimport { SelectFactory } from '../decorators/select/select-factory';\nimport { ROOT_STATE_TOKEN } from '../symbols';\nimport { StateClassInternal, StatesAndDefaults } from '../internal/internals';\nimport { LifecycleStateManager } from '../internal/lifecycle-state-manager';\nimport { InitState } from '../actions/actions';\nimport { setIvyEnabledInDevMode } from '../ivy/ivy-enabled-in-dev-mode';\n\n/**\n * Root module\n * @ignore\n */\n@NgModule()\nexport class NgxsRootModule {\n  constructor(\n    factory: StateFactory,\n    internalStateOperations: InternalStateOperations,\n    _store: Store,\n    _select: SelectFactory,\n    @Optional()\n    @Inject(ROOT_STATE_TOKEN)\n    states: StateClassInternal[] = [],\n    lifecycleStateManager: LifecycleStateManager\n  ) {\n    // Validate states on having the `@Injectable()` decorator in Ivy\n    setIvyEnabledInDevMode();\n\n    // Add stores to the state graph and return their defaults\n    const results: StatesAndDefaults = factory.addAndReturnDefaults(states);\n\n    internalStateOperations.setStateToTheCurrentWithNew(results);\n\n    // Connect our actions stream\n    factory.connectActionHandlers();\n\n    // Dispatch the init action and invoke init and bootstrap functions after\n    lifecycleStateManager.ngxsBootstrap(new InitState(), results);\n  }\n}\n","import { Inject, NgModule, Optional } from '@angular/core';\n\nimport { Store } from '../store';\nimport { InternalStateOperations } from '../internal/state-operations';\nimport { StateFactory } from '../internal/state-factory';\nimport { FEATURE_STATE_TOKEN } from '../symbols';\nimport { LifecycleStateManager } from '../internal/lifecycle-state-manager';\nimport { StateClassInternal, StatesAndDefaults } from '../internal/internals';\nimport { UpdateState } from '../actions/actions';\n\n/**\n * Feature module\n * @ignore\n */\n@NgModule()\nexport class NgxsFeatureModule {\n  constructor(\n    _store: Store,\n    internalStateOperations: InternalStateOperations,\n    factory: StateFactory,\n    @Optional()\n    @Inject(FEATURE_STATE_TOKEN)\n    states: StateClassInternal[][] = [],\n    lifecycleStateManager: LifecycleStateManager\n  ) {\n    // Since FEATURE_STATE_TOKEN is a multi token, we need to\n    // flatten it [[Feature1State, Feature2State], [Feature3State]]\n    const flattenedStates: StateClassInternal[] = NgxsFeatureModule.flattenStates(states);\n\n    // add stores to the state graph and return their defaults\n    const results: StatesAndDefaults = factory.addAndReturnDefaults(flattenedStates);\n\n    if (results.states.length) {\n      internalStateOperations.setStateToTheCurrentWithNew(results);\n\n      // dispatch the update action and invoke init and bootstrap functions after\n      lifecycleStateManager.ngxsBootstrap(new UpdateState(results.defaults), results);\n    }\n  }\n\n  private static flattenStates(states: StateClassInternal[][] = []): StateClassInternal[] {\n    return states.reduce(\n      (total: StateClassInternal[], values: StateClassInternal[]) => total.concat(values),\n      []\n    );\n  }\n}\n","import {\n  APP_BOOTSTRAP_LISTENER,\n  InjectionToken,\n  isDevMode,\n  ModuleWithProviders,\n  NgModule,\n  Provider\n} from '@angular/core';\nimport {\n  INITIAL_STATE_TOKEN,\n  InitialState,\n  isAngularInTestMode,\n  NGXS_STATE_CONTEXT_FACTORY,\n  NGXS_STATE_FACTORY,\n  NgxsBootstrapper,\n  StateClass\n} from '@ngxs/store/internals';\n\nimport {\n  FEATURE_STATE_TOKEN,\n  NG_DEV_MODE,\n  NG_TEST_MODE,\n  NgxsConfig,\n  NgxsModuleOptions,\n  ROOT_STATE_TOKEN\n} from './symbols';\nimport { NGXS_EXECUTION_STRATEGY } from './execution/symbols';\nimport { StateFactory } from './internal/state-factory';\nimport { StateContextFactory } from './internal/state-context-factory';\nimport { Actions, InternalActions } from './actions-stream';\nimport { LifecycleStateManager } from './internal/lifecycle-state-manager';\nimport { InternalDispatchedActionResults, InternalDispatcher } from './internal/dispatcher';\nimport { InternalStateOperations } from './internal/state-operations';\nimport { Store } from './store';\nimport { SelectFactory } from './decorators/select/select-factory';\nimport { StateStream } from './internal/state-stream';\nimport { PluginManager } from './plugin-manager';\nimport { NgxsRootModule } from './modules/ngxs-root.module';\nimport { NgxsFeatureModule } from './modules/ngxs-feature.module';\nimport { DispatchOutsideZoneNgxsExecutionStrategy } from './execution/dispatch-outside-zone-ngxs-execution-strategy';\nimport { InternalNgxsExecutionStrategy } from './execution/internal-ngxs-execution-strategy';\nimport { HostEnvironment } from './host-environment/host-environment';\nimport { ConfigValidator } from './internal/config-validator';\n\n/**\n * Ngxs Module\n */\n@NgModule()\nexport class NgxsModule {\n  private static readonly ROOT_OPTIONS = new InjectionToken<NgxsModuleOptions>('ROOT_OPTIONS');\n\n  /**\n   * Root module factory\n   */\n  public static forRoot(\n    states: StateClass[] = [],\n    options: NgxsModuleOptions = {}\n  ): ModuleWithProviders<NgxsRootModule> {\n    return {\n      ngModule: NgxsRootModule,\n      providers: [\n        StateFactory,\n        StateContextFactory,\n        Actions,\n        InternalActions,\n        NgxsBootstrapper,\n        ConfigValidator,\n        HostEnvironment,\n        LifecycleStateManager,\n        InternalDispatcher,\n        InternalDispatchedActionResults,\n        InternalStateOperations,\n        InternalNgxsExecutionStrategy,\n        Store,\n        StateStream,\n        SelectFactory,\n        PluginManager,\n        ...states,\n        ...NgxsModule.ngxsTokenProviders(states, options)\n      ]\n    };\n  }\n\n  /**\n   * Feature module factory\n   */\n  public static forFeature(states: StateClass[] = []): ModuleWithProviders<NgxsFeatureModule> {\n    return {\n      ngModule: NgxsFeatureModule,\n      providers: [\n        StateFactory,\n        PluginManager,\n        ...states,\n        {\n          provide: FEATURE_STATE_TOKEN,\n          multi: true,\n          useValue: states\n        }\n      ]\n    };\n  }\n\n  private static ngxsTokenProviders(\n    states: StateClass[],\n    options: NgxsModuleOptions\n  ): Provider[] {\n    return [\n      {\n        provide: NG_TEST_MODE,\n        useValue: isAngularInTestMode\n      },\n      {\n        provide: NG_DEV_MODE,\n        useValue: isDevMode\n      },\n      {\n        provide: NGXS_EXECUTION_STRATEGY,\n        useClass: options.executionStrategy || DispatchOutsideZoneNgxsExecutionStrategy\n      },\n      {\n        provide: ROOT_STATE_TOKEN,\n        useValue: states\n      },\n      {\n        provide: NgxsModule.ROOT_OPTIONS,\n        useValue: options\n      },\n      {\n        provide: NgxsConfig,\n        useFactory: NgxsModule.ngxsConfigFactory,\n        deps: [NgxsModule.ROOT_OPTIONS]\n      },\n      {\n        provide: APP_BOOTSTRAP_LISTENER,\n        useFactory: NgxsModule.appBootstrapListenerFactory,\n        multi: true,\n        deps: [NgxsBootstrapper]\n      },\n      {\n        provide: INITIAL_STATE_TOKEN,\n        useFactory: NgxsModule.getInitialState\n      },\n      {\n        provide: NGXS_STATE_CONTEXT_FACTORY,\n        useExisting: StateContextFactory\n      },\n      {\n        provide: NGXS_STATE_FACTORY,\n        useExisting: StateFactory\n      }\n    ];\n  }\n\n  private static ngxsConfigFactory(options: NgxsModuleOptions): NgxsConfig {\n    return Object.assign(new NgxsConfig(), options);\n  }\n\n  private static appBootstrapListenerFactory(bootstrapper: NgxsBootstrapper): Function {\n    return () => bootstrapper.bootstrap();\n  }\n\n  private static getInitialState() {\n    return InitialState.pop();\n  }\n}\n","import { ivyEnabledInDevMode } from './ivy-enabled-in-dev-mode';\nimport { CONFIG_MESSAGES, VALIDATION_CODE } from '../configs/messages.config';\n\n/**\n * All provided or injected tokens must have `@Injectable` decorator\n * (previously, injected tokens without `@Injectable` were allowed\n * if another decorator was used, e.g. pipes).\n */\nexport function ensureStateClassIsInjectable(target: any): void {\n  // `ÃÂµprov` is a static property added by the NGCC compiler. It always exists in\n  // AOT mode because this property is added before runtime. If an application is running in\n  // JIT mode then this property can be added by the `@Injectable()` decorator. The `@Injectable()`\n  // decorator has to go after the `@State()` decorator, thus we prevent users from unwanted DI errors.\n  ivyEnabledInDevMode().subscribe(_ivyEnabledInDevMode => {\n    if (_ivyEnabledInDevMode) {\n      const ngInjectableDef = target.ÃÂµprov;\n      if (!ngInjectableDef) {\n        // Don't warn if Ivy is disabled or `ÃÂµprov` exists on the class\n        console.warn(CONFIG_MESSAGES[VALIDATION_CODE.UNDECORATED_STATE_IN_IVY](target.name));\n      }\n    }\n  });\n}\n","import { Observable } from 'rxjs';\n\nimport { CONFIG_MESSAGES, VALIDATION_CODE } from '../../configs/messages.config';\nimport { propGetter } from '../../internal/internals';\nimport { SelectFactory } from './select-factory';\nimport { StateToken } from '../../state-token/state-token';\nimport { ExtractTokenType } from '../../state-token/symbols';\n\nconst DOLLAR_CHAR_CODE = 36;\n\nexport function createSelectObservable<T = any>(selector: any): Observable<T> {\n  if (!SelectFactory.store) {\n    throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.SELECT_FACTORY_NOT_CONNECTED]());\n  }\n\n  return SelectFactory.store.select(selector);\n}\n\nexport function createSelectorFn(name: string, rawSelector?: any, paths: string[] = []): any {\n  rawSelector = !rawSelector ? removeDollarAtTheEnd(name) : rawSelector;\n\n  if (typeof rawSelector === 'string') {\n    const propsArray: string[] = paths.length\n      ? [rawSelector, ...paths]\n      : rawSelector.split('.');\n    return propGetter(propsArray, SelectFactory.config!);\n  }\n\n  return rawSelector;\n}\n\n/**\n * @example If `foo$` => make it just `foo`\n */\nexport function removeDollarAtTheEnd(name: string): string {\n  const lastCharIndex: number = name.length - 1;\n  const dollarAtTheEnd: boolean = name.charCodeAt(lastCharIndex) === DOLLAR_CHAR_CODE;\n  return dollarAtTheEnd ? name.slice(0, lastCharIndex) : name;\n}\n\nexport type PropertyType<T> = T extends StateToken<any>\n  ? Observable<ExtractTokenType<T>>\n  : T extends (...args: any[]) => any\n  ? Observable<ReturnType<T>>\n  : any;\n\nexport type ComponentClass<T> = {\n  [P in keyof T]: T[P];\n};\n\nexport type SelectType<T> = <\n  U extends ComponentClass<any> & Record<K, PropertyType<T>>,\n  K extends string\n>(\n  target: U,\n  key: K\n) => void;\n","import { Injectable } from '@angular/core';\n\nimport { NgxsExecutionStrategy } from './symbols';\n\n@Injectable()\nexport class NoopNgxsExecutionStrategy implements NgxsExecutionStrategy {\n  enter<T>(func: () => T): T {\n    return func();\n  }\n\n  leave<T>(func: () => T): T {\n    return func();\n  }\n}\n","import { TokenName } from './symbols';\nimport {\n  ensureSelectorMetadata,\n  RuntimeSelectorContext,\n  SelectFromRootState\n} from '../internal/internals';\n\nexport class StateToken<T = void> {\n  constructor(private readonly name: TokenName<T>) {\n    const selectorMetadata = ensureSelectorMetadata(<any>this);\n    selectorMetadata.makeRootSelector = (\n      runtimeContext: RuntimeSelectorContext\n    ): SelectFromRootState => {\n      return runtimeContext.getStateGetter(this.name);\n    };\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  toString(): string {\n    return `StateToken[${this.name}]`;\n  }\n}\n","import { ensureStoreMetadata } from '../internal/internals';\nimport { ActionType, ActionOptions } from '../actions/symbols';\nimport { CONFIG_MESSAGES, VALIDATION_CODE } from '../configs/messages.config';\n\n/**\n * Decorates a method with a action information.\n */\nexport function Action(\n  actions: ActionType | ActionType[],\n  options?: ActionOptions\n): MethodDecorator {\n  return (target: any, name: string | symbol): void => {\n    const isStaticMethod = target.hasOwnProperty('prototype');\n\n    if (isStaticMethod) {\n      throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.ACTION_DECORATOR]());\n    }\n\n    const meta = ensureStoreMetadata(target.constructor);\n\n    if (!Array.isArray(actions)) {\n      actions = [actions];\n    }\n\n    for (const action of actions) {\n      const type = action.type;\n\n      if (!meta.actions[type]) {\n        meta.actions[type] = [];\n      }\n\n      meta.actions[type].push({\n        fn: name,\n        options: options || {},\n        type\n      });\n    }\n  };\n}\n","import {\n  ComponentClass,\n  createSelectObservable,\n  createSelectorFn,\n  PropertyType,\n  SelectType\n} from './symbols';\n\n/**\n * Decorator for selecting a slice of state from the store.\n */\nexport function Select<T>(rawSelector?: T, ...paths: string[]): SelectType<T> {\n  return function<\n    U extends ComponentClass<any> & Record<K, PropertyType<T>>,\n    K extends string\n  >(target: U, key: K): void {\n    const name: string = key.toString();\n    const selectorId = `__${name}__selector`;\n    const selector = createSelectorFn(name, rawSelector, paths);\n\n    Object.defineProperties(target, {\n      [selectorId]: {\n        writable: true,\n        enumerable: false,\n        configurable: true\n      },\n      [name]: {\n        enumerable: true,\n        configurable: true,\n        get(): PropertyType<T> {\n          return this[selectorId] || (this[selectorId] = createSelectObservable(selector));\n        }\n      }\n    });\n  };\n}\n","import { CONFIG_MESSAGES, VALIDATION_CODE } from '../../configs/messages.config';\nimport { createSelector } from '../../utils/selector-utils';\nimport { SelectorSpec, SelectorType } from './symbols';\n\n/**\n * Decorator for memoizing a state selector.\n */\nexport function Selector<T>(selectors?: T[]): SelectorType<T> {\n  return <U>(\n    target: any,\n    key: string | symbol,\n    descriptor: TypedPropertyDescriptor<SelectorSpec<T, U>>\n  ): TypedPropertyDescriptor<SelectorSpec<T, U>> | void => {\n    const isNotMethod = !(descriptor && descriptor.value !== null);\n\n    if (isNotMethod) {\n      throw new Error(CONFIG_MESSAGES[VALIDATION_CODE.SELECTOR_DECORATOR]());\n    }\n\n    const originalFn = descriptor.value;\n    const memoizedFn = createSelector(selectors, originalFn as any, {\n      containerClass: target,\n      selectorName: key.toString(),\n      getSelectorOptions() {\n        return {};\n      }\n    });\n    const newDescriptor = {\n      configurable: true,\n      get() {\n        return memoizedFn;\n      }\n    };\n    // Add hidden property to descriptor\n    (<any>newDescriptor)['originalFn'] = originalFn;\n    return newDescriptor;\n  };\n}\n","import { SharedSelectorOptions } from '../internal/internals';\nimport { selectorOptionsMetaAccessor } from '../utils/selector-utils';\n\n/**\n * Decorator for setting selector options at a method or class level.\n */\nexport function SelectorOptions(options: SharedSelectorOptions) {\n  return <ClassDecorator & MethodDecorator>(\n    function decorate<T>(\n      target: any,\n      methodName: string,\n      descriptor: TypedPropertyDescriptor<T>\n    ) {\n      if (methodName) {\n        // Method Decorator\n        const originalFn = descriptor.value || (<any>descriptor).originalFn;\n        if (originalFn) {\n          selectorOptionsMetaAccessor.defineOptions(originalFn, options);\n        }\n      } else {\n        // Class Decorator\n        selectorOptionsMetaAccessor.defineOptions(target, options);\n      }\n    }\n  );\n}\n","import { StateClass } from '@ngxs/store/internals';\n\nimport { ensureStoreMetadata, MetaDataModel, StateClassInternal } from '../internal/internals';\nimport { META_KEY, META_OPTIONS_KEY, StoreOptions } from '../symbols';\nimport { StoreValidators } from '../utils/store-validators';\nimport { ensureStateClassIsInjectable } from '../ivy/ensure-state-class-is-injectable';\n\ninterface MutateMetaOptions<T> {\n  meta: MetaDataModel;\n  inheritedStateClass: StateClassInternal;\n  optionsWithInheritance: StoreOptions<T>;\n}\n\n/**\n * Decorates a class with ngxs state information.\n */\nexport function State<T>(options: StoreOptions<T>) {\n  function getStateOptions(inheritedStateClass: StateClassInternal): StoreOptions<T> {\n    const inheritanceOptions: Partial<StoreOptions<T>> =\n      inheritedStateClass[META_OPTIONS_KEY] || {};\n    return { ...inheritanceOptions, ...options } as StoreOptions<T>;\n  }\n\n  function mutateMetaData(params: MutateMetaOptions<T>): void {\n    const { meta, inheritedStateClass, optionsWithInheritance } = params;\n    const { children, defaults, name } = optionsWithInheritance;\n    const stateName: string | null =\n      typeof name === 'string' ? name : (name && name.getName()) || null;\n    StoreValidators.checkCorrectStateName(stateName);\n\n    if (inheritedStateClass.hasOwnProperty(META_KEY)) {\n      const inheritedMeta: Partial<MetaDataModel> = inheritedStateClass[META_KEY] || {};\n      meta.actions = { ...meta.actions, ...inheritedMeta.actions };\n    }\n\n    meta.children = children;\n    meta.defaults = defaults;\n    meta.name = stateName;\n  }\n\n  return (target: StateClass): void => {\n    ensureStateClassIsInjectable(target);\n    const stateClass: StateClassInternal = target;\n    const meta: MetaDataModel = ensureStoreMetadata(stateClass);\n    const inheritedStateClass: StateClassInternal = Object.getPrototypeOf(stateClass);\n    const optionsWithInheritance: StoreOptions<T> = getStateOptions(inheritedStateClass);\n    mutateMetaData({ meta, inheritedStateClass, optionsWithInheritance });\n    stateClass[META_OPTIONS_KEY] = optionsWithInheritance;\n  };\n}\n","import {\n  getSelectorMetadata as getSelectorMetadataInternal,\n  getStoreMetadata as getStoreMetadataInternal,\n  ensureStoreMetadata as ensureStoreMetadataInternal,\n  ensureSelectorMetadata as ensureSelectorMetadataInternal,\n  StateClassInternal,\n  SharedSelectorOptions\n} from './internal/internals';\nimport { PlainObjectOf } from '../internals/src/symbols';\nimport { ActionHandlerMetaData } from './actions/symbols';\n\ninterface MetaDataModel {\n  name: string | null;\n  actions: PlainObjectOf<ActionHandlerMetaData[]>;\n  defaults: any;\n  path: string | null;\n  // selectFromAppState: SelectFromState | null;\n  // makeRootSelector: SelectorFactory | null; // Don't expose new stuff\n  children?: StateClassInternal[];\n}\n\ninterface SelectorMetaDataModel {\n  // selectFromAppState: SelectFromState | null;\n  // makeRootSelector: SelectorFactory | null; // Don't expose new stuff\n  originalFn: Function | null;\n  containerClass: any;\n  selectorName: string | null;\n  getSelectorOptions: () => SharedSelectorOptions;\n}\n\nexport function ensureStoreMetadata(target: StateClassInternal<any, any>): MetaDataModel {\n  return ensureStoreMetadataInternal(target);\n}\n\nexport function getStoreMetadata(target: StateClassInternal<any, any>): MetaDataModel {\n  return getStoreMetadataInternal(target);\n}\n\nexport function ensureSelectorMetadata(target: Function): SelectorMetaDataModel {\n  return ensureSelectorMetadataInternal(target);\n}\n\nexport function getSelectorMetadata(target: any): SelectorMetaDataModel {\n  return getSelectorMetadataInternal(target);\n}\n"]}